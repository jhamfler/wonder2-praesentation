{"version":3,"sources":["wonder.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"wonder.js","sourcesContent":["/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n * @version 0.1.0\n */\n\n'use strict';\n\n(function(undefined) {\n  if (typeof(define) === 'function' && define.amd) {\n    define([\n      'adapter',\n      'Conversation',\n      'Demand',\n      'helpfunctions',\n      'Identity',\n      'Idp',\n      'Message',\n      'MessageFactory',\n      'MsgEvtHandler',\n      'Participant',\n      'RtcEvtHandler',\n      'Types',\n      'DataChannelEvtHandler'\n    ], function() {\n      /**\n       * @class\n       * @desc The WONDER class is used for developers for interacting with all other WONDER related classes.\n       * The class uses simple interfaces for login, call, etc.\n       * All operations will start with wonder.<function-name> and will return a promise and a callback (either successCallback or errorCallback).\n       * @example wonder.<funcion>(<params>).then(function(successCallbackData){<code>}, function(errorCallbackData){<code>})\n       * @return {WONDER}\n       * @alias module:wonder\n       */\n      class WONDER {\n        /**\n         * @constructor\n         * @example\n         * // needs to be included in a html file\n         * <script src=\"require.min.js\"></script>\n         * <script type=\"text/javascript\">\n         *   // require.config is optional and only necessary if the wonder framework is not in the same directory like require.js\n         *   // for additional information visit: http://requirejs.org/docs/api.html#config\n         *   require.config({\n         *     paths: { 'wonder': 'js/wonder' } // includes js/wonder.js\n         *   });\n         *   require(['wonder'], function(wonderInstance){\n         *     wonderInstance.login(\"alice@example.org\");\n         *     // do other things here like calling bob\n         *   });\n         * </script>\n         */\n        constructor() {\n          /**\n           * @type {Object} config\n           * @desc An object with a configuration\n           * The standard values are set by default when the user doesn't want to do\n           * it on his own.\n           * @example\n           * {\n           *  idp: 'webfinger',\n           *  // alternatively an own idp with:\n           *  // idp:{ url:  \"http://example.com\",\n           *  //       port: '2222',\n           *  //       path: '/u?jsonp=define&identity'   }\n           *  autoAccept: false, // accept invitations automatically\n           *  ice: [\n           *     {urls:'stun:stun.example.com'}, // stunserver\n           *     { // turnserver\n           *       urls: 'turn:turn.example.org:11111?transport=tcp',\n           *       credential: 'credeantialAccessString',\n           *       username: 'usernameToAccess'\n           *     }\n           *   ]\n           * }\n           */\n          this.config = {\n            // automatic accept all invitations\n            autoAccept: true,\n\n            // location of the identity provider\n            idp: 'webfinger', // default value (search for identities with webfinger)\n\n            // default ice servers\n            ice: [{\n              urls: 'stun:stun.voiparound.com'\n            }, {\n              urls: 'stun:stun.voipbuster.com'\n            }, {\n              urls: 'stun:stun.voipstunt.com'\n            }, {\n              urls: 'stun:stun.voxgratia.org'\n            }, {\n              urls: 'stun:stun.ekiga.net'\n            }, {\n              urls: 'stun:stun.schlund.de'\n            }, {\n              urls: 'stun:stun.iptel.org'\n            }, {\n              urls: 'stun:stun.l.google.com:19302'\n            }, {\n              urls: 'stun:stun1.l.google.com:19302'\n            }, {\n              urls: 'stun:stun.ideasip.com'\n            }, {\n              urls: 'stun:stun4.l.google.com:19302'\n            }, {\n              urls: 'stun:stun2.l.google.com:19302'\n            }, {\n              urls: 'stun:stun3.l.google.com:19302'\n            }, {\n              urls: 'turn:192.158.29.39:3478?transport=tcp',\n              credential: 'JZEOEt2V3Qb0y27GRntt2u2PAYA=',\n              username: '28224511:1379330808'\n            }, {\n              urls: 'turn:192.158.29.39:3478?transport=udp',\n              credential: 'JZEOEt2V3Qb0y27GRntt2u2PAYA=',\n              username: '28224511:1379330808'\n            }, {\n              urls: 'turn:numb.viagenie.ca',\n              credential: 'muazkh',\n              username: 'webrtc@live.com'\n            }]\n          };\n\n          /**\n           * @type {Array<Conversation>} conversations\n           * @desc The conversations used in this WONDER instance\n           */\n          this.conversations = [];\n\n          /**\n           * @type {Identity} myIdentity\n           * @desc The identity of the local user\n           */\n          this.myIdentity = null;\n\n          /**\n           * @type {Idp} localIdp\n           * @desc The local identity provider residing in the local WONDER instance\n           * used to interact with the remote identity provider. It is there to be\n           * able to abstact the remote identity provider and define a common\n           * interface to WONDER functions.\n           * It resolves identities via WebFinger or JSONP.\n           */\n          this.localIdp = null;\n\n          /**\n           * @type {function(msg: Message, conversationId: GUID)} onMessage\n           * @desc The variable on which the framework user can register his own message event handler.\n           * It is called after the WONDER framework is finished processing each message.\n           * Is meant to deliver events which originate from the messaging server.\n           * @example wonder.onMessage = function(msg, conversationId) { ... }\n           */\n          this.onMessage = new Function();\n\n\n          /**\n           * @type {function(msg: Object, conversationId: GUID)} onRtcEvt\n           * @desc The variable on which the framework user can register an event handler for wonder rtc (peer connection) events.\n           * It is called after the WONDER framework is finished processing each\n           * Is meant to deliver events which originate from the peer connection to another user.\n           * @example wonder.onRtcEvt = function(msg, conversationId) { ... }\n           */\n          this.onRtcEvt = new Function();\n\n          /**\n           * @type {function(msg: Object, conversationId: GUID)} onDataChannelEvt\n           * @desc The variable on which the framework user can register an event handler for wonder data channel events.\n           * It is called after the WONDER framework is finished processing each\n           * Is meant to deliver events which originate from the peer connection's datachannels to another user.\n           * @example wonder.onDataChannelEvt = function(msg, conversationId){ ... }\n           */\n          this.onDataChannelEvt = new Function();\n        }\n\n        /**\n         * @desc The function starts a user login at the identity provider.\n         * @param {String} myRtcIdentity - The username (login name) of the local identity\n         * @param {Object} credentials - An object with additional login credentials (password, sip-credentials, etc.); may be undefined or null or an empty string\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         * @return {Promise<Identity>|function(identity: Identity)}\n         * @example\n         * wonder.login(\"alice@example.net\", \"\")\n         * .then(function(identity){\n         *   // use the identity to extract the user's aliases, avatar or other information\n         * });\n         */\n        login(myRtcIdentity, credentials, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          console.log('[WONDER login] login with:', myRtcIdentity);\n\n          return new Promise(function(resolve, reject) {\n\n            // errorCallback handling\n            if (!myRtcIdentity) {\n              errMsg = new Error('[WONDER login] errorCallback: no login name received');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n            if (credentials === undefined || credentials === null) credentials = '';\n            if (!that.localIdp) {\n              if (typeof that.config.idp === 'string' && that.config.idp === 'webfinger') {\n                console.log('[WONDER login] looking for identities using Webfinger...');\n                that.localIdp = new Idp('webfinger', myRtcIdentity);\n              } else if (typeof that.config.idp === 'object') {\n                that.localIdp = new Idp(that.config.idp.url + ':' + that.config.idp.port + that.config.idp.path, myRtcIdentity);\n              } else {\n                errMsg = new Error('[WONDER login] errorCallback: Wrong idp format in configuration');\n                reject(errMsg);\n                if (errorCallback) errorCallback(errMsg);\n                return;\n              }\n            }\n\n            that.localIdp.getIdentity(myRtcIdentity, credentials)\n              .then(function(identity) {\n                console.log('[WONDER login]: got identity: ', identity);\n                that.myIdentity = identity;\n                var invitationHandler = new MsgEvtHandler(that); // we need to receive invitations\n                // as we are registering the handler on the messaging stub we need to replace the reference to\n                // this == msgStub with this == invitationHandler\n                identity.msgStub.onMessage = invitationHandler.onMessage.bind(invitationHandler);\n                // SD 06.10.15: add credentials to the identity\n                identity.credentials = credentials;\n\n                identity.msgStub.connect( // and connect to the own mesaging server\n                  identity.rtcIdentity,\n                  identity.credentials,\n                  identity.msgSrv,\n                  function() { // successCallback connecting\n                    console.log('[WONDER login] connected to msgServer of identity: ', identity);\n                    resolve(identity);\n                    if (successCallback) successCallback(identity);\n                  }\n                );\n\n              })\n              .catch(function(err) { // possibly a network errorCallback\n                errMsg = new Error('[WONDER login] ', err);\n                reject(errMsg);\n                if (errorCallback) errorCallback(errMsg);\n                return;\n              });\n          });\n        }\n\n\n\n        /**\n         * @desc A function to start a new call.\n         *\n         * @param {Array<String>|String} recipients - The rtcIdentity as a string for the reciepients (e.g. alice@example.com)\n         * @param {String|Array<String>|Object} demand - An object with the own media constraints for the offer\n         * @param {GUID} [conversationId] - To assign a call to an exiting conversation\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         * @return {Promise<GUID>|function(conversationId: GUID)}\n         * @example\n         * wonder.call(\"bob@example.com\", {video: true, data: PayloadType.chat})\n         * .then(function(conversationId){\n         *   // show video and send chat messages\n         * });\n         */\n        call(recipients, demand, conversationId, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            // errorCallback handling\n            if (!recipients) {\n              errMsg = new Error('[WONDER call] no recipients');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n            if (!demand) {\n              errMsg = new Error('[WONDER call] no demand');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n            demand = new Demand(demand); // convert the demand to the standard format\n\n            // TODO: only do that if no conversationId is given\n            var existingConversation = null;\n            if (typeof recipients === 'string' || recipients instanceof String) {\n              // check if te remote rtcIdentity is already in a conversation\n              existingConversation = that.conversations.find(\n                function(conversation) {\n                  return conversation.remoteParticipants.find(\n                    function(participant) {\n                      return participant.identity.rtcIdentity == recipients;\n                    }\n                  )\n                }\n              );\n            }\n            if (typeof recipients === 'array' || recipients instanceof Array) return new Error(\"[wonder call] multiparty no yet implemented\");\n\n            if (!existingConversation) {\n              // create a new conversation\n              var conversation = new Conversation(that, new Participant(that, that.myIdentity, demand)); // create me and set me as the owner\n              conversation.myParticipant = conversation.owner; // copy the reference to me\n              that.conversations.push(conversation); // add the conversation to wonder\n              conversation.myParticipant.setRtcPeerConnection(\n                new RTCPeerConnection({\n                  'iceServers': that.config.ice // name of key needs to be iceServers in RTCPeerConnection\n                    //,dataChannelOptions\n                })\n              );\n            } else {\n              var conversation = existingConversation;\n              conversation.myParticipant.updateDemand(demand);\n            }\n\n            // set ice handling to false before receiving all sdp messages to avoid ICE errors\n            conversation.msgEvtHandler.ice = false;\n\n            // dynamically load a file for a specific use case\n            // require file for a multiparty call\n            if (typeof recipients === 'array' || recipients instanceof Array) {\n              // TODO: implement multiparty support\n              if (demand.out.video || demand.out.audio) {\n                require(['callMultiple'], function(callMultiple) {\n                  callMultiple(wonderInstance, recipients, conversation)\n                    .then(function(conversationId) {\n                      resolve(conversationId);\n                      if (successCallback) successCallback(conversationId);\n                    })\n                    .catch(function(error) {\n                      errMsg = new Error(\"[WONDER call] Error in callMultiple occured: \", error);\n                      reject(errMsg);\n                      if (errorCallback) errorCallback(errMsg);\n                      return;\n                    });\n                });\n              }\n            }\n            // require file for a single call\n            else if (typeof recipients === 'string' || recipients instanceof String) {\n              // start a video / audio call\n              if (demand.out.video || demand.out.audio) {\n                require(['callSingle'], function(callSingle) {\n                  callSingle(that, recipients, conversation, demand)\n                    .then(function(conversationId) {\n                      resolve(conversationId);\n                      if (successCallback) successCallback(conversationId);\n                    })\n                    .catch(function(error) {\n                      errMsg = new Error(\"[WONDER call] Error in callSingle occured: \", error);\n                      reject(errMsg);\n                      if (errorCallback) errorCallback(errMsg);\n                      return;\n                    });\n                });\n              }\n              // start a data channel\n              if (demand.out.data) {\n                require(['dataChannel'], function(dataChannel) {\n                  dataChannel(that, recipients, conversation, demand.out.data) // also hand over the data object to tell what payload type is wanted\n                    .then(function(conversationId) {\n                      resolve(conversationId);\n                      if (successCallback) successCallback(conversationId);\n                    })\n                    .catch(function(error) {\n                      errMsg = new Error(\"[WONDER call] Error in dataChannel occured: \", error);\n                      reject(errMsg);\n                      if (errorCallback) errorCallback(errMsg);\n                      return;\n                    });\n                });\n              }\n            } else {\n              errMsg = new Error(\"[WONDER call] cannot determine wether it is a multi or single party call\");\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n          });\n        }\n\n\n\n        /**\n         * @desc A function to remove a reciepient from an existing conversation\n         * only used for multiparty calls\n         *\n         * @param {Array.<String>|String} recipients - The username(s) for the reciepients\n         * @param {GUID} [conversationId] - To remove a call from an exiting conversation\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         *\n         * @return {Promise<GUID>|function(conversationId: GUID)}\n         * !!! not implemented yet\n         * TODO: implement\n\n        removeRecipients(recipients, conversationId, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            // errorCallback handling\n            if (!recipients) {\n              errMsg = new Error('[WONDER removeRecipients] errorCallback: no reciepients given')\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n            // force an array construct\n            var rcpt = [];\n            if (typeof recipients === 'string') rcpt.push(recipients);\n            else rcpt = recipients;\n\n            // TODO : implement\n            // conversation.addParticipant(participant, invitationBody, constraints, function(){resolve()}, function(){reject()});\n\n          });\n        }\n        */\n\n        /**\n         * @desc Add demand to an existing conversation\n         *\n         * @param {Object} type - a media constraint object containing the new media constraints\n         * @param {GUID} [conversationId] - To add constraints to an exiting conversation\n         * @param {function} [successCallback] - A success callback.\n         * @param {function} [errorCallback] - An error callback.\n         *\n         * @return {Promise<GUID>|function(conversationId: GUID)}\n         * !!! not implemented yet\n         * TODO: implement\n\n        addDemand(type, conversationId, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            // errorCallback handling\n            if (!type) {\n              errMsg = new Error('[WONDER addDemand] errorCallback: no type given');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n          });\n        }\n         */\n\n        /**\n         * @desc Remove demand from an existing conversation\n         *\n         * @param {Object} type - a media constraint object containing the media constraints wich should be removed\n         * @param {GUID} [conversationId] - To remove constraints from an exiting conversation\n         * @param {function} [successCallback] - A success callback.\n         * @param {function} [errorCallback] - An error callback.\n         *\n         * @return {Promise<GUID>|function(conversationId: GUID)}\n         * !!! not implemented yet\n         * TODO: implement\n\n        removeDemand(type, conversationId, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            // errorCallback handling\n            if (!type) {\n              errMsg = new Error('[WONDER removeDemand] errorCallback: no type given');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n          });\n        }\n         */\n\n        /**\n         * @desc A function to logout a user from his and all other messaging servers.\n         * The hangup function will be called to close all conversations.\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         * @return {Promise<Boolean>|function(success: Boolean)}\n         * @example wonder.logout().then( function(){ ... } );\n         */\n        logout(successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            // errorCallback handling\n            if (!that.myIdentity) {\n              errMsg = new Error('[WONDER logout] not logged in');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n\n            // hangup all conversations\n            if (that.conversations.length > 0) that.hangup();\n\n            // disconnect from own messaging server\n            if (that.myIdentity.msgStub) that.myIdentity.msgStub.disconnect();\n            else {\n              errMsg = new Error(\"[WONDER logout] no messaging Stub present\");\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n\n            resolve(true);\n            if (successCallback) successCallback(true);\n          });\n        }\n\n\n        /**\n         * @desc A function to hangup a single conversation or all conversations.\n         * @param {GUID} [conversationId] - Id of the of the conversation to be closed\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         * @return {Promise<Boolean>|function(success: Boolean)}\n         * @example wonder.hangup(conversationId).then( function(){ ... } );\n         */\n        hangup(conversationId, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            // error handling\n            if (that.conversations.length == 0) {\n              errMsg = new Error(\"[WONDER hangup] no conversation present\");\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n            }\n\n            if (!conversationId) { // hangup all conversations\n              for (var i = 0; i < that.conversations.length; i++) {\n                that.conversations[i].leave();\n              }\n              that.conversations = [];\n            } else { // close a single conversation\n              var conversation = that.conversations.find(function(id) {\n                return id == conversationId;\n              });\n              conversation.leave();\n              conversation = null; // TODO: check if a conversation of null is still in the array\n            }\n\n            resolve(true);\n            if (successCallback) successCallback(true);\n          });\n        }\n\n\n        /**\n         * @desc Sends a new data channel message via the RTCDataChannel.\n         * @param {Object} msg - An object containing the message to be sent\n         * @param {PayloadType|String} type - The type of the payload (as a string or the well known PayloadType) of the data channel message\n         * @param {GUID} [conversationId] - The conversationId of the conversation's data channel the message will be sent to\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         * @return {Promise<Boolean>|function(success: Boolean)}\n         * @example\n         * msg = \"Text or Message or Object or anything. Is handeled by the codec.\";\n         * wonder.dataChannelMsg(msg, PayloadType.plain, conversationId)\n         * .then(function(booleanValue){\n         *   // success\n         * });\n         */\n        dataChannelMsg(msg, type, conversationId, to, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n          console.log(\"[WONDER dataChannelMsg] \", msg);\n          return new Promise(function(resolve, reject) {\n            if (that.conversations.length == 0) {\n              errMsg = new Error(\"[WONDER dataChannelMsg] no conversation present\");\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n            }\n\n            // if no conversation use the dafault single party call method\n            if (!conversationId) {\n              var remoteIdentity = that.conversations[0].remoteParticipants[0].identity;\n              try {\n                that.conversations[0].dataChannelBroker.getDataChannelCodec(that.myIdentity, remoteIdentity, type).send(msg);\n                resolve(true);\n                if (successCallback) successCallback(true);\n              } catch (err) {\n                errMsg = new Error('[WONDER dataChannelMsg] There is no dataChannel for this Codec established');\n                reject(errMsg);\n                if (errorCallback) errorCallback(errMsg);\n              }\n            } else { // else find the conversation\n              var conversation = that.conversations.find(\n                function(conversation) {\n                  return conversation.id == conversationId;\n                }\n              );\n              if (conversation) { // and if it was found send the message\n                var remoteIdentity = conversation.remoteParticipants[0].identity;\n                conversation.dataChannelBroker.getDataChannelCodec(that.myIdentity, remoteIdentity, type).send(msg);\n                resolve(true);\n                if (successCallback) successCallback(true);\n              } else { // and if not throw an error\n                errMsg = new Error('[WONDER dataChannelMsg] no conversation found');\n                reject(errMsg);\n                if (errorCallback) errorCallback(errMsg);\n              }\n            }\n          });\n        }\n\n        /**\n         * @desc This function needs to be called if the autoAccept option in the WONDER instacne is false.\n         * It needs to be used after the invitation is received and an answer is necessary.\n         * @param {Message} msg - The invitation message to be accepted or declined\n         * @param {Boolean} action - A Boolean value (true = accepted, false = declined)\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         * @return {Promise<GUID>|function(conversationId: GUID)}\n         * @example\n         *   wonder.onMessage = function(msg, conversationId){\n         *     switch (msg.type) {\n         *       case MessageType.invitation:\n         *         if(!wonder.config.autoAccept) {\n         *           var confirmDialog = confirm('Call from '+msg.from+'. Would you like to accept?');\n         *           if (confirmDialog == true) {\n         *               wonder.answerRequest(msg, true).then(function(){\n         *                 console.log('[main] Message invitation: user accepted invtitation');\n         *               });\n         *           } else {\n         *               wonder.answerRequest(msg, false).then(function(){\n         *                 console.log('[main] Message invitation: user declined invtitation');\n         *               });\n         *           }\n         *       }\n         *       break;\n         *     }\n         *   }\n         */\n        answerRequest(msg, action, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            var conversation = that.conversations.find(\n              function(conversation) {\n                return conversation.id == msg.conversationId;\n              }\n            );\n            if (conversation) { // and if it was found send the message\n              conversation.msgEvthandler.answerRequest(msg, action);\n              resolve(conversation.id);\n              if (successCallback) successCallback(conversation.id);\n            } else { // and if not throw an error\n              errMsg = new Error('[WONDER answerRequest] no conversation found');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n            }\n          });\n        }\n\n      }\n\n      return new WONDER();\n    });\n  } else if (typeof window === 'object') {\n    window.wonder = new WONDER();\n    // TODO implement other classes if framework isn't required as amd module\n  } else {\n    try {\n      module.exports = new WONDER();\n      // TODO import other classes if browser supports es6 import/export\n    } catch (e) {}\n  }\n})();\n"],"sourceRoot":"/source/"}
[
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/Conversation.js",
    "memberof": null,
    "longname": "libs/modules/Conversation.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\n/**\n * @class\n * @desc This class is the central class for controlling conversations\n */\nclass Conversation {\n  /**\n   * @constructor\n   * @param {WONDER} wonderInstance - The instance of wonder to which the conversation is related to\n   * @param {String} [owner] - Defines the owner of the conversation, usually the caller\n   */\n  constructor(wonderInstance, owner) {\n    /**\n     * @type {GUID} id\n     * @desc A unique identifier for a conversation which is created automatically\n     */\n    this.id = guid();\n\n    /**\n     * @type {Wonder} wonderInstance\n     * @desc The wonder instance on which the conversation is located on\n     * @desc Makes backreferences possible\n     */\n    this.wonderInstance = wonderInstance;\n\n    /**\n     * @type {Participant} myParticipant\n     * @desc The local participant of the conversation\n     */\n    this.myParticipant = null;\n\n    /**\n     * @type {Participant} owner\n     * @desc The participant who owns the conversation which is usually the caller\n     */\n    this.owner = owner || null;\n\n    /**\n     * @type {Array<Participant>} remoteParticipants\n     * @desc An array of all remote {@link Participant}s participating in that conversation\n     */\n    this.remoteParticipants = [];\n\n    /**\n     * @type {MsgEvtHandler} msgEvtHandler\n     * @desc The message event handler instance of the conversation which handles all incoming messages from the conversation's messaging server\n     * @example conversation.msgEvtHandler = new MsgEvtHandler(wonderInstance, conversation);\n     */\n    this.msgEvtHandler = new MsgEvtHandler(this.wonderInstance, this);\n\n    /**\n     * @type {RtcEvtHandler} rtcEvtHandler\n     * @desc The rtc event handler instance of the conversation which handles all events related to a rtc peer connection#\n     * @TODO: Move this to the Participant-class as a peer connection is established to another participant.\n     * This needs to be done and working before multiparty code is written.\n     * @example conversation.rtcEvtHandler = new RtcEvtHandler(wonderInstance, conversation);\n     */\n    this.rtcEvtHandler = new RtcEvtHandler(this.wonderInstance, this);\n\n    /**\n     * @type {DataChannelEvtHandler} dataChannelEvtHandler\n     * @desc The data cannel event handler for data channel events of a specific channel.\n     * The event handler is registered only if a data channel is required.\n     * @TODO: check if this isn't needed anymore as the codec has the handler\n     * @example conversation.dataChannelEvtHandler = new dataChannelEvtHandler(wonderInstance, conversation);\n     */\n    this.dataChannelEvtHandler = null;\n\n    /**\n     * @type {MessagingStub} msgStub\n     * @desc The messaging stub implementation instance of the messaging server which is used in this conversation\n     */\n    this.msgStub = null;\n\n    /**\n     * @type {String} msgSrv\n     * @desc A URL as a string to a messaging server which is used in this conversation\n     */\n    this.msgSrv = null;\n\n    /**\n     * @type {DataChannelBroker} dataChannelBroker\n     * @desc The broker which stores and handles codecs and its data channels which are used in this conversation\n     */\n    this.dataChannelBroker = null;\n  }\n\n\n  /**\n   * @desc Leaves the conversation on which the function is executed on\n   * @example conversation.leave();\n   */\n  leave() {\n    var that = this;\n    that.myParticipant.peerConnection.close();\n    for (var i = 0; i < that.remoteParticipants.length; i++) {\n      // this will trigger the iceconnectionstatechange event on the remote end\n      // remote end needs to check pc.iceConnectionState == disconnected\n      if (that.remoteParticipants[i].peerConnection) that.remoteParticipants[i].peerConnection.close();\n      // as the message is delivered trough the pc event a separate message isn't mandatory here\n    }\n    if (that.msgStub) that.msgStub.disconnect(); // now disconnect from the remote messaging server\n  }\n\n\n  /**\n   * @desc Adds a new remote participant to the conversation\n   * @param {Participant} participant - The remote participant which should be added to the conversation\n   */\n  addRemoteParticipant(participant) {\n    var existingParticipant = this.remoteParticipants.find(\n      function(remoteParticipant) {\n        return remoteParticipant.identity == participant.identity;\n      }\n    );\n    if (!existingParticipant) this.remoteParticipants.push(participant);\n  }\n\n\n  /**\n   * @desc Searches an existing participant in the conversation's remote participants\n   * and return it if it exists\n   * @param {Identity} identity - The identity of the remote participant to be returned\n   * @return {Participant}\n   */\n  getRemoteParticipant(identity) {\n    var existingParticipant = this.remoteParticipants.find(\n      function(remoteParticipant) {\n        return remoteParticipant.identity == identity;\n      }\n    );\n    if (existingParticipant) return existingParticipant;\n    return null;\n  }\n}\n"
  },
  {
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Conversation",
    "memberof": "libs/modules/Conversation.js",
    "longname": "libs/modules/Conversation.js~Conversation",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/modules/Conversation.js",
    "importStyle": null,
    "description": "This class is the central class for controlling conversations",
    "lineNumber": 14,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#constructor",
    "access": null,
    "description": null,
    "lineNumber": 20,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "WONDER"
        ],
        "spread": false,
        "optional": false,
        "name": "wonderInstance",
        "description": "The instance of wonder to which the conversation is related to"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "owner",
        "description": "Defines the owner of the conversation, usually the caller"
      }
    ],
    "generator": false
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "id",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#id",
    "access": null,
    "description": "A unique identifier for a conversation which is created automatically",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "GUID"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "wonderInstance",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#wonderInstance",
    "access": null,
    "description": "Makes backreferences possible",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "Wonder"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "myParticipant",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#myParticipant",
    "access": null,
    "description": "The local participant of the conversation",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "Participant"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "owner",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#owner",
    "access": null,
    "description": "The participant who owns the conversation which is usually the caller",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "Participant"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "remoteParticipants",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#remoteParticipants",
    "access": null,
    "description": "An array of all remote {@link Participant}s participating in that conversation",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "Array<Participant>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "msgEvtHandler",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#msgEvtHandler",
    "access": null,
    "description": "The message event handler instance of the conversation which handles all incoming messages from the conversation's messaging server",
    "examples": [
      "conversation.msgEvtHandler = new MsgEvtHandler(wonderInstance, conversation);"
    ],
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "MsgEvtHandler"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "rtcEvtHandler",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#rtcEvtHandler",
    "access": null,
    "description": "The rtc event handler instance of the conversation which handles all events related to a rtc peer connection#\n@TODO: Move this to the Participant-class as a peer connection is established to another participant.\nThis needs to be done and working before multiparty code is written.",
    "examples": [
      "conversation.rtcEvtHandler = new RtcEvtHandler(wonderInstance, conversation);"
    ],
    "lineNumber": 66,
    "type": {
      "nullable": null,
      "types": [
        "RtcEvtHandler"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "dataChannelEvtHandler",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#dataChannelEvtHandler",
    "access": null,
    "description": "The data cannel event handler for data channel events of a specific channel.\nThe event handler is registered only if a data channel is required.\n@TODO: check if this isn't needed anymore as the codec has the handler",
    "examples": [
      "conversation.dataChannelEvtHandler = new dataChannelEvtHandler(wonderInstance, conversation);"
    ],
    "lineNumber": 75,
    "type": {
      "nullable": null,
      "types": [
        "DataChannelEvtHandler"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "msgStub",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#msgStub",
    "access": null,
    "description": "The messaging stub implementation instance of the messaging server which is used in this conversation",
    "lineNumber": 81,
    "type": {
      "nullable": null,
      "types": [
        "MessagingStub"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "msgSrv",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#msgSrv",
    "access": null,
    "description": "A URL as a string to a messaging server which is used in this conversation",
    "lineNumber": 87,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "dataChannelBroker",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#dataChannelBroker",
    "access": null,
    "description": "The broker which stores and handles codecs and its data channels which are used in this conversation",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "DataChannelBroker"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "leave",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#leave",
    "access": null,
    "description": "Leaves the conversation on which the function is executed on",
    "examples": [
      "conversation.leave();"
    ],
    "lineNumber": 101,
    "params": [],
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "addRemoteParticipant",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#addRemoteParticipant",
    "access": null,
    "description": "Adds a new remote participant to the conversation",
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "Participant"
        ],
        "spread": false,
        "optional": false,
        "name": "participant",
        "description": "The remote participant which should be added to the conversation"
      }
    ],
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getRemoteParticipant",
    "memberof": "libs/modules/Conversation.js~Conversation",
    "longname": "libs/modules/Conversation.js~Conversation#getRemoteParticipant",
    "access": null,
    "description": "Searches an existing participant in the conversation's remote participants\nand return it if it exists",
    "lineNumber": 134,
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "The identity of the remote participant to be returned"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Participant"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/DataChannelBroker.js",
    "memberof": null,
    "longname": "libs/modules/DataChannelBroker.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\ndefine(function() {\n  /**\n   * @class\n   * @desc This class represents a data broker for codecs and their data channels\n   * @return {DataChannelBroker}\n   */\n  class DataChannelBroker {\n    /**\n     * @constructor\n     */\n    constructor() {\n      /**\n       * @desc This is an object containing a map for assigned codecs between a sender and a recipient.\n       * The object makes it possible to search a codec instance by going down the hierarchy in the following order:\n       * from -> to -> payloadType ->  [ codec | url | dataChannelEvtHandler ]\n       * @type {Object} codecMap\n       * @example\n       * { // view of alice (sending direction) begins here\n       *  alice: {\n       *    bob: {\n       *      file: {\n       *        url: \"https://example.net:8083/codecs/file.js\", // the url to the origin of the codec\n       *        dataChannleEvtHandler: DataChannelEvtHandler, // an instance of the event handler\n       *        codec: codec // an instance of the codec which includes data channel\n       *      },\n       *      plain: {\n       *        url: \"http://example.org:8083/codecs/plain.js\",\n       *        dataChannleEvtHandler: DataChannelEvtHandler,\n       *        codec: codec\n       *      }\n       *    }\n       *    charlie: {\n       *      chat: {\n       *        url: \"http://example.com:8083/codecs/chatcodec.js\",\n       *        dataChannleEvtHandler: DataChannelEvtHandler,\n       *        codec: codec\n       *      }\n       *    }\n       *  },\n       *  // receiving direction begins here\n       *  bob: {\n       *    alice: {\n       *      file: {\n       *        url: \"https://example.net:8083/codecs/fileCodec2.js\",\n       *        dataChannleEvtHandler: DataChannelEvtHandler,\n       *        codec: codec\n       *      }\n       *    }\n       *  },\n       *  charlie: {\n       *    alice: {\n       *      chat: {\n       *        url: \"http://charlie.example.net:8083/codecs/charliesChatCodec.js\",\n       *        dataChannleEvtHandler: DataChannelEvtHandler,\n       *        codec: codec\n       *      }\n       *    }\n       *  }\n       * }\n       */\n      this.codecMap = {};\n\n      /**\n       * @type {Object} codecs\n       * @desc An object of all available codecs with the codecUrl as a key\n       * It contains the instances of each required codec. The codecs are then used to\n       * instanciate the codecs in the codecMap so they can be used multiple times.\n       * @example\n       * {\n       *   \"http://example.org:8083/chat.js\" : chatCodec, // instance of a codec\n       *   \"https://example.net:8070/file.js\" : fileCodec,\n       *   \"https://example.com:8090/image.js\" : imageCodec\n       * }\n       */\n      this.codecs = {};\n    }\n\n\n    /**\n     * @desc The function adds a new codec from one peer to another\n     * with the codecUrl as the key.\n     * @param {Identity} from - The senders Identity\n     * @param {Identity} to - The recipient's Identity\n     * @param {PayloadType|String} payloadType - The type of the payload for the codec which may be derived from PayloadType or be a self defined string also present in the identity as a key to a codec\n     * @param {DataChannelEvtHandler} dataChannelEvtHandler - The instance of DataChannelEvtHandler used for the codecs data channel\n     * @return {Promise<Codec>}\n     * @TODO add error handling if no codec is retrieved if(codec == false) ...\n     * @TODO check if hasownproperty or try-catch is better suited\n     */\n    addDataChannelCodec(from, to, payloadType, dataChannelEvtHandler) {\n      var that = this;\n      var errMsg;\n\n      return new Promise(function(resolve, reject) {\n        // when no codecs were webfingered from bob or the payloadType doesn't match the codecs\n        if (!to.codecs || !to.codecs[payloadType]) {\n          // check if the codec doesn't matter\n          if (payloadType == true) payloadType = PayloadType.plain; // fallback to codec plain\n          else { // alice is requesting a codec that bob doesn't have\n            errMsg = new Error(\"[DataChannelBroker addDataChannelCodec] Payload type not found for the remote participant\");\n            reject(errMsg);\n            return errMsg;\n          }\n        } // else payload type found\n\n        that.getCodec(to.codecs[payloadType]) // get the codec file\n        .then(function(codec) { // iterate through the object and resolve missing hierarchies\n          if (!that.codecMap[from.rtcIdentity]) that.codecMap[from.rtcIdentity] = {};\n          if (!that.codecMap[from.rtcIdentity][to.rtcIdentity]) that.codecMap[from.rtcIdentity][to.rtcIdentity] = {};\n          if (!that.codecMap[from.rtcIdentity][to.rtcIdentity][payloadType]) that.codecMap[from.rtcIdentity][to.rtcIdentity][payloadType] = {};\n          that.codecMap[from.rtcIdentity][to.rtcIdentity][payloadType].url = to.codecs[payloadType]; // write the url\n          that.codecMap[from.rtcIdentity][to.rtcIdentity][payloadType].dataChannelEvtHandler = dataChannelEvtHandler; // save the handler\n          resolve(codec); // resolve the promise of addDataChannelCodec\n        })\n        .catch(function(error) {\n          errMsg = new Error(\"[DataChannelBroker addDataChannelCodec] error saving the codec in the codecMap:\", error);\n          reject(errMsg);\n          return errMsg;\n        });\n      });\n    }\n\n\n    /**\n     * @desc Returns a codec and its data channel which is used from one peer to another with the codecUrl as a key\n     * @param {Identity} from - The senders Identity\n     * @param {Identity} to - The recipient's Identity\n     * @param {PayloadType|String} payloadType - The type of the payload for the codec which may be derived from PayloadType or be a self defined string also present in the identity as a key to a codec\n     * @return {Promise<Object>|false}\n     * @example\n     * var codec = dataChannelBroker.getDataChannelCodec(remoteIdentity, myIdentity, \"https://example.com/codecFile.js\");\n     * @TODO: add an instance of the codec to the codecMap, it is currently only in codecs\n     * @TODO check if hasownproperty or try-catch is better suited\n     */\n    getDataChannelCodec(from, to, payloadType) {\n      if ((payloadType == true) || !payloadType) payloadType = PayloadType.plain; // fallback to codec plain\n      if (this.codecMap[from.rtcIdentity]                                             &&\n          this.codecMap[from.rtcIdentity][to.rtcIdentity]                             &&\n          this.codecMap[from.rtcIdentity][to.rtcIdentity][payloadType]                &&\n          this.codecMap[from.rtcIdentity][to.rtcIdentity][payloadType].url            &&\n          this.codecs[this.codecMap[from.rtcIdentity][to.rtcIdentity][payloadType].url]) {\n            return this.codecs[this.codecMap[from.rtcIdentity][to.rtcIdentity][payloadType].url]; // return the codec\n      }\n      return false; // if not found\n    }\n\n\n    /**\n     * @desc Remove a codec and its RTCDataChannel\n     * @param {Identity} from - The senders Identity\n     * @param {Identity} to - The recipient's Identity\n     * @param {PayloadType|String} payloadType - The type of the payload for the codec which may be derived from PayloadType or be a self defined string also present in the identity as a key to a codec\n     * @return {Boolean}\n     * @example\n     * var success = dataChannelBroker.removeDataChannelCodec(myIdentity, remoteIdentity, \"http://example.com/codec.js\");\n     * @TODO delete also the data channel evnt handler and everything instide the codec to be sure everything is removed\n     * @TODO check if hasownproperty or try-catch is better suited\n     */\n    removeDataChannelCodec(from, to, payloadType) {\n      // check if the connection is there\n      // check iteratively to avoid exceptions\n      if (this.codecMap[from.rtcIdentity]                             &&\n          this.codecMap[from.rtcIdentity][to.rtcIdentity]             &&\n          this.codecMap[from.rtcIdentity][to.rtcIdentity][payloadType]) {\n            delete this.codecMap[from.rtcIdentity][to.rtcIdentity][payloadType];\n            return true;\n      }\n      return false; // if not found\n    }\n\n\n    /**\n     * @desc Get a specific codec from the local codec list or from a remote server\n     * @param {String} codecUrl - an URL pointing to the related codec file which is also used as a key for the codecs-list\n     * @return {Promise<Object>} codec\n     * @example\n     * dataChannelBroker.getCodec(\"https://c.example.net/anyCodec.js\")\n     * .then(function(codec){\n     *   console.log(\"Codec found: \", codec);\n     *   // do something with the codec variable\n     * })\n     * .catch(function(error){\n     *   console.error(\"Error found: \", error);\n     * });\n     */\n    getCodec(codecUrl) {\n      var that = this;\n\n      return new Promise(function(resolve, reject) {\n        // error handling\n        if (!codecUrl) {\n          reject(Error(\"[DataChannelBroker getCodec] : no codecUrl specified\"));\n          return;\n        }\n\n        // search for the codec by URL\n        if (that.codecs && that.codecs[codecUrl]) {\n          resolve(that.codecs[codecUrl]);\n          return;\n        } else { // if it isn't present download the codec with the URL\n          require([codecUrl],\n            function(codec) { // successfully received the codec\n              that.codecs[codecUrl] = codec; // save it locally\n              resolve(codec); // and return it\n            },\n            function(error) { // failed to receive the codec\n              reject(new Error('[DataChannelBroker getCodec] the codec could not be retrieved from the remote server: ', error));\n            }\n          );\n        }\n      });\n    }\n\n\n    /**\n     * @desc This function removes a codec with a given url to a codec origin.\n     * This function may not be needed at all since we may want to be able to\n     * preserve every codecs for the application/conversation lifetime.\n     * @param {String} codecUrl - an URL pointing to the related codec file\n     * @return {Boolean}\n     * @example var success = dataChannelBroker.removeCodec(\"https://codecs.example.org/imageCodec.js\");\n     */\n    removeCodec(codecUrl) {\n      if (this.codecs[codecUrl]) {\n        delete this.codecs[codecUrl];\n        return true;\n      }\n      else return false;\n    }\n  }\n\n  return new DataChannelBroker();\n});\n"
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/DataChannelEvtHandler.js",
    "memberof": null,
    "longname": "libs/modules/DataChannelEvtHandler.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\n/**\n * @class\n * @desc This class is an event handler for events coming from a RTCDataChannel.\n */\nclass DataChannelEvtHandler {\n  /**\n   * @constructor\n   * @param {WONDER} wonderInstance - A reference to the instance of the WONDER class to which the DataChannelEvtHandler is related\n   * @param {Conversation} conversation - An reference to the instance of the Conversation class to which the DataChannelEvtHandler is related\n   * @example var dataChannelEvtHandler = new DataChannelEvtHandler(wonderIntance, conversation);\n   */\n  constructor(wonderInstance, conversation) {\n    /**\n     * @type {WONDER} wonderInstance\n     * @desc A reference to the wonder instance on which the data channel event handler is used\n     */\n    this.wonderInstance = wonderInstance;\n\n    /**\n     * @type {Conversation} conversation\n     * @desc A reference to the conversation the data channel event handler is present on\n     */\n    this.conversation = conversation;\n\n    /**\n     * @type {RTCDataChannel} dataChannel\n     * @desc A reference to the data channel for which the data channel event handler handles events\n     */\n    this.dataChannel;\n  }\n\n\n  /**\n   * @desc This function processes the events of a data channel.\n   * Is is ment to be called after the events were processed by the datachannel's codec\n   * but could also be used directly on the datachannel without a codec.\n   * @param {Object} evt - The Event originationg from a RTCDataChannel\n   * @example // usage without the codec inbetween\n   * var dataChannel = peerConnection.createDataChannel(guid());\n   * dataChannel.onmessage = dataChannelEvtHandler.onEvt.bind(dataChannelEvtHandler);\n   * @example // usage with the codec inbetween\n   * codec.dataChannel = peerConnection.createDataChannel(guid());\n   * codec.dataChannel.onmessage = codec.onDataMessage.bind(codec);\n   * codec.onMessage = dataChannelEvtHandler.onEvt.bind(dataChannelEvtHandler);\n   */\n  onEvt(evt) { // getting the conversation from the constructor doesnt work as on\n    var that = this;\n    console.log(\"[DataChannelEvtHandler] event:\", evt);\n\n    switch (evt.type) {\n      case DataChannelEvtType.onopen:\n        //console.log(\"this should be never ever called\");\n        console.log('[DataChannelEvtHandler onEvt] onopen', evt);\n        // if the data channel is established the onmessage listener can be called\n        //if (that.dataChannel.readyState === 'open') that.dataChannel.onmessage = that.onEvt;\n        if (dataChannel.readyState === 'open') dataChannel.onmessage = that.onEvt;\n        //if (that.conversation.dc.readyState === 'open') that.conversation.dc.onmessage = that.onEvt;\n        break;\n\n      case DataChannelEvtType.onclose:\n        console.log('[DataChannelEvtHandler onEvt] onclose', evt);\n        break;\n\n      case DataChannelEvtType.ondatachannel:\n        console.log('[DataChannelEvtHandler onEvt] ondatachannel', evt);\n        break;\n\n      case DataChannelEvtType.onmessage:\n        console.log('[DataChannelEvtHandler onEvt] onmessage', evt);\n\n        break;\n\n      default:\n        console.log('[DataChannelEvtHandler onEvt] default', evt);\n        break;\n    }\n\n    this.wonderInstance.onDataChannelEvt(evt);\n  }\n\n\n}\n"
  },
  {
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "DataChannelEvtHandler",
    "memberof": "libs/modules/DataChannelEvtHandler.js",
    "longname": "libs/modules/DataChannelEvtHandler.js~DataChannelEvtHandler",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/modules/DataChannelEvtHandler.js",
    "importStyle": null,
    "description": "This class is an event handler for events coming from a RTCDataChannel.",
    "lineNumber": 14,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "libs/modules/DataChannelEvtHandler.js~DataChannelEvtHandler",
    "longname": "libs/modules/DataChannelEvtHandler.js~DataChannelEvtHandler#constructor",
    "access": null,
    "description": null,
    "examples": [
      "var dataChannelEvtHandler = new DataChannelEvtHandler(wonderIntance, conversation);"
    ],
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "WONDER"
        ],
        "spread": false,
        "optional": false,
        "name": "wonderInstance",
        "description": "A reference to the instance of the WONDER class to which the DataChannelEvtHandler is related"
      },
      {
        "nullable": null,
        "types": [
          "Conversation"
        ],
        "spread": false,
        "optional": false,
        "name": "conversation",
        "description": "An reference to the instance of the Conversation class to which the DataChannelEvtHandler is related"
      }
    ],
    "generator": false
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "wonderInstance",
    "memberof": "libs/modules/DataChannelEvtHandler.js~DataChannelEvtHandler",
    "longname": "libs/modules/DataChannelEvtHandler.js~DataChannelEvtHandler#wonderInstance",
    "access": null,
    "description": "A reference to the wonder instance on which the data channel event handler is used",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "WONDER"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "conversation",
    "memberof": "libs/modules/DataChannelEvtHandler.js~DataChannelEvtHandler",
    "longname": "libs/modules/DataChannelEvtHandler.js~DataChannelEvtHandler#conversation",
    "access": null,
    "description": "A reference to the conversation the data channel event handler is present on",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "Conversation"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "onEvt",
    "memberof": "libs/modules/DataChannelEvtHandler.js~DataChannelEvtHandler",
    "longname": "libs/modules/DataChannelEvtHandler.js~DataChannelEvtHandler#onEvt",
    "access": null,
    "description": "This function processes the events of a data channel.\nIs is ment to be called after the events were processed by the datachannel's codec\nbut could also be used directly on the datachannel without a codec.",
    "examples": [
      "// usage without the codec inbetween\nvar dataChannel = peerConnection.createDataChannel(guid());\ndataChannel.onmessage = dataChannelEvtHandler.onEvt.bind(dataChannelEvtHandler);",
      "// usage with the codec inbetween\ncodec.dataChannel = peerConnection.createDataChannel(guid());\ncodec.dataChannel.onmessage = codec.onDataMessage.bind(codec);\ncodec.onMessage = dataChannelEvtHandler.onEvt.bind(dataChannelEvtHandler);"
    ],
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "evt",
        "description": "The Event originationg from a RTCDataChannel"
      }
    ],
    "generator": false
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/Demand.js",
    "memberof": null,
    "longname": "libs/modules/Demand.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\n/**\n * @class\n * @desc This class converts different data demand types to a pre-defined format.\n * The Format contains an 'in' and 'out' object which is used to differentiate local and remote media access.\n * The output could look like this:\n * @TODO change data-object in demand to be ablte to hold an array or another object containing multiple payload types\n * @example\n * {\n *  in: {\n *    video: {\n *      mandatory: { minAspectRatio: 1.333, maxAspectRatio: 1.334 },\n *      optional : [\n *        { minFrameRate: 60 },\n *        { maxWidth: 640 },\n *        { maxHeigth: 480 }\n *      ]\n *    }\n *    audio: true,\n *    data: true\n *  },\n *  out: {\n *    video: {\n *      mandatory: { minAspectRatio: 1.4},\n *      optional : [\n *        { minFrameRate: 20 },\n *        { maxWidth: 800 }\n *      ]\n *    }\n *    audio: false,\n *    data: \"chat\"\n *  }\n * }\n */\nclass Demand {\n  /**\n   * @constructor\n   * @param {String|Array<String>|Object} data - The resources which are requested\n   * @example\n   * var demand = new Demand(\"all\"); // demand video, audio and a data channel\n   * var demand = new Demand(\"audio\"); // demands audio for both directions\n   * var demand = new Demand(\"noRealTypeLikeVideoOrAudioOrData\"); // demands nothing\n   * var demand = new Demand([\"audio\",\"data\"]); // demands audio and data for both directions\n   * var demand = new Demand({in: \"video\", out: \"audio\"}); // demands incoming video and outgoing audio\n   * var demand = new Demand({out:{data:true,video:false}}}); // demands only an outgoing data channel\n   * @desc The constructor can be called with different data types and converts it to the necessary object.\n   * It doesn't return the Demand-object itself rather than a general object describing the demand in a structured way.\n   */\n  constructor(data) {\n    return Demand.convertDemand(data, Demand.getStandardDemand());\n  }\n\n  /**\n   * @desc This defines the format for the output as an object.\n   * @return {Object}\n   */\n  static getStandardDemand() {\n    return {\n      in : {\n        'audio': false,\n        'video': false,\n        'data': false\n      },\n      out: {\n        'audio': false,\n        'video': false,\n        'data': false\n      }\n    };\n  }\n\n\n  /**\n   * @desc The function converts different demand requests to a unified format.\n   * @param {String|Array<String>|Object} data - The requested demand which should be converted\n   * @param {Object} demand - The standard demand object\n   * @return {Object}\n   */\n  static convertDemand(data, demand) {\n\n    // case data is a string\n    if (typeof data === 'string' || data instanceof String) {\n      if (data === '' || data === 'all') return demandAll(demand);\n      else return stringToDemand(data, demand);\n    }\n\n    // case data is an array of Strings\n    else if (data instanceof Array) {\n      if (data.length === 0) return demandAll(demand);\n      else return arrayToDemand(data, demand);\n    }\n\n    // case data is an Object\n    else if (data instanceof Object) {\n      if (data === null || data === undefined || Object.keys(data).length === 0) return demandAll(demand);\n      return objectToDemand(data, demand);\n    }\n    else return demandAll(demand);\n\n\n    /**\n     * @desc Convertes a string to a standardized format\n     * @param {String} data - The requested demand which should be converted\n     * @param {Object} demand - The standard demand object\n     * @return {Object}\n     */\n    function stringToDemand(data, demand) {\n      console.log('[Demand convertDemand] converting String:', data, 'to Demand ', demand);\n\n      if (demand.in.hasOwnProperty(data) && demand.out.hasOwnProperty(data)) {\n        demand.in[data] = true;\n        demand.out[data] = true;\n      }\n      return demand;\n    }\n\n\n    /**\n     * @desc Convertes an array to a standardized format\n     * @param {Array<String>} data - The requested demand which should be converted\n     * @param {Object} demand - The standard demand object\n     * @return {Object}\n     */\n    function arrayToDemand(data, demand) {\n      console.log('[Demand convertDemand] converting Array:', data, 'to Demand');\n\n      for (var i = 0; i < data.length; i++) {\n        if (demand.in.hasOwnProperty(data[i]) && demand.out.hasOwnProperty(data[i])) {\n          demand.in[data[i]] = true;\n          demand.out[data[i]] = true;\n        }\n      }\n\n      return demand;\n    }\n\n\n    /**\n     * @desc Convertes an object to a standardized format\n     * @param {Object} data - The requested demand which should be converted\n     * @param {Object} demand - The standard demand object\n     * @return {Object}\n     */\n    function objectToDemand(data, demand) {\n      console.log('[Demand convertDemand] converting Object:', data, 'to Demand');\n\n      // if already has the sub-objects \"in\" and \"out\"\n      if (data.hasOwnProperty('in') || data.hasOwnProperty('out')) {\n        // iterate through \"in\" and \"out\"\n        for (var direction in demand) {\n          // iterate through demand types (\"audio\", \"video\", \"data\")\n          for (var prop in demand[direction]) {\n            if (data[direction].hasOwnProperty(prop)) {\n              if (data[direction][prop] === true || data[direction][prop] === false || typeof data[direction][prop] == 'object' || data[direction][prop] instanceof Object) {\n                demand[direction][prop] = data[direction][prop];\n              } else {\n                if (prop == \"data\") {\n                  demand[direction][prop] = data[direction][prop]; // { data: \"chat\" }\n                }\n                else demand[direction][prop] = false;\n              }\n            }\n          }\n        }\n        // if \"in\" and \"out\" is not specified, set attributes for both directions\n      } else {\n        for (var prop in demand.in) {\n          if (data.hasOwnProperty(prop)) {\n            if (data[prop] === true || data[prop] === false || typeof data[prop] == 'object' || data[prop] instanceof Object) {\n              demand.in[prop] = data[prop];\n              demand.out[prop] = data[prop];\n            } else {\n              if (typeof data[prop] == 'string' || data[prop] instanceof String) {// { data: \"plain\" }\n                demand.in[prop] = data[prop]; // {in: {data : \"plain\"}}\n                demand.out[prop] = data[prop]; // {in: {data : \"plain\"}}\n              } else {\n                demand.in[prop] = false;\n                demand.out[prop] = false;\n              }\n            }\n          }\n        }\n      }\n\n      return demand;\n    }\n\n    /**\n     * @desc Returns a demand which requires everything as a standardized demand format\n     * @return {Object}\n     */\n    function demandAll() {\n      console.log('[Demand convertDemand] Wrong format:', data, 'using backup: set all to true');\n\n      return {\n        in : {\n          'audio': true,\n          'video': true,\n          'data': true\n        },\n        out: {\n          'audio': true,\n          'video': true,\n          'data': true\n        }\n      };\n\n    }\n  }\n\n\n  /**\n   * @desc The function assigns all properties which are wanted in the additional demand to the target demand.\n   * @param {Object} targetDemand - The targeted demand to be modified\n   * @param {Object} additionalDemand - The additinal demand which should be added to the targetDemand\n   * @return {Object}\n   * @example Demand.updateDemandAllow(demandToModify, demandToAdd);\n   */\n  static updateDemandAllow(targetDemand, additionalDemand){\n    targetDemand     = this.convertDemand(targetDemand    , this.getStandardDemand());\n    additionalDemand = this.convertDemand(additionalDemand, this.getStandardDemand());\n\n    // iterate through \"in\" and \"out\"\n    for (var direction in targetDemand) {\n      // iterate through demand types (\"audio\", \"video\", \"data\")\n      for (var prop in targetDemand[direction]) {\n          // if the property is true in the additionalDemand then add it ti the targetDemand\n          if (additionalDemand[direction][prop]) targetDemand[direction][prop] = additionalDemand[direction][prop];\n      }\n    }\n    return targetDemand;\n  }\n\n\n   /**\n    * @desc The function sets all properties which are not wanted in the restrictive demand to false in the target demand.\n    * @param {Object} targetDemand - The targeted demand an which a specific demand type should be removed\n    * @param {Object} restrictiveDemand - The demand which should be set to false in the targetDemand\n    * @return {Object}\n    * @example\n    * Demand.updateDemandDisallow(demandToModify, demandToRemove);\n    * Demand.updateDemandDisallow(demandToModify, {data:true}) // sets data to false in demandToModify\n    */\n  static updateDemandDisallow(targetDemand, restrictiveDemand){\n    targetDemand      = this.convertDemand(targetDemand     , this.getStandardDemand());\n    restrictiveDemand = this.convertDemand(restrictiveDemand, this.getStandardDemand());\n\n    // iterate through \"in\" and \"out\"\n    for (var direction in targetDemand) {\n      // iterate through demand types (\"audio\", \"video\", \"data\")\n      for (var prop in targetDemand[direction]) {\n          // if the property is false in the restriction, then add it to the targetDemand\n          if (restrictiveDemand[direction][prop]) targetDemand[direction][prop] = false;\n      }\n    }\n    return targetDemand;\n  }\n}\n"
  },
  {
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Demand",
    "memberof": "libs/modules/Demand.js",
    "longname": "libs/modules/Demand.js~Demand",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/modules/Demand.js",
    "importStyle": null,
    "description": "This class converts different data demand types to a pre-defined format.\nThe Format contains an 'in' and 'out' object which is used to differentiate local and remote media access.\nThe output could look like this:",
    "examples": [
      "{\n in: {\n   video: {\n     mandatory: { minAspectRatio: 1.333, maxAspectRatio: 1.334 },\n     optional : [\n       { minFrameRate: 60 },\n       { maxWidth: 640 },\n       { maxHeigth: 480 }\n     ]\n   }\n   audio: true,\n   data: true\n },\n out: {\n   video: {\n     mandatory: { minAspectRatio: 1.4},\n     optional : [\n       { minFrameRate: 20 },\n       { maxWidth: 800 }\n     ]\n   }\n   audio: false,\n   data: \"chat\"\n }\n}"
    ],
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      },
      {
        "tagName": "@TODO",
        "tagValue": "change data-object in demand to be ablte to hold an array or another object containing multiple payload types"
      }
    ],
    "interface": false
  },
  {
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "libs/modules/Demand.js~Demand",
    "longname": "libs/modules/Demand.js~Demand#constructor",
    "access": null,
    "description": "The constructor can be called with different data types and converts it to the necessary object.\nIt doesn't return the Demand-object itself rather than a general object describing the demand in a structured way.",
    "examples": [
      "var demand = new Demand(\"all\"); // demand video, audio and a data channel\nvar demand = new Demand(\"audio\"); // demands audio for both directions\nvar demand = new Demand(\"noRealTypeLikeVideoOrAudioOrData\"); // demands nothing\nvar demand = new Demand([\"audio\",\"data\"]); // demands audio and data for both directions\nvar demand = new Demand({in: \"video\", out: \"audio\"}); // demands incoming video and outgoing audio\nvar demand = new Demand({out:{data:true,video:false}}}); // demands only an outgoing data channel"
    ],
    "lineNumber": 57,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String",
          "Array<String>",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The resources which are requested"
      }
    ],
    "generator": false
  },
  {
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "getStandardDemand",
    "memberof": "libs/modules/Demand.js~Demand",
    "longname": "libs/modules/Demand.js~Demand.getStandardDemand",
    "access": null,
    "description": "This defines the format for the output as an object.",
    "lineNumber": 65,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "convertDemand",
    "memberof": "libs/modules/Demand.js~Demand",
    "longname": "libs/modules/Demand.js~Demand.convertDemand",
    "access": null,
    "description": "The function converts different demand requests to a unified format.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "String",
          "Array<String>",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The requested demand which should be converted"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "demand",
        "description": "The standard demand object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "updateDemandAllow",
    "memberof": "libs/modules/Demand.js~Demand",
    "longname": "libs/modules/Demand.js~Demand.updateDemandAllow",
    "access": null,
    "description": "The function assigns all properties which are wanted in the additional demand to the target demand.",
    "examples": [
      "Demand.updateDemandAllow(demandToModify, demandToAdd);"
    ],
    "lineNumber": 227,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "targetDemand",
        "description": "The targeted demand to be modified"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "additionalDemand",
        "description": "The additinal demand which should be added to the targetDemand"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "updateDemandDisallow",
    "memberof": "libs/modules/Demand.js~Demand",
    "longname": "libs/modules/Demand.js~Demand.updateDemandDisallow",
    "access": null,
    "description": "The function sets all properties which are not wanted in the restrictive demand to false in the target demand.",
    "examples": [
      "Demand.updateDemandDisallow(demandToModify, demandToRemove);\nDemand.updateDemandDisallow(demandToModify, {data:true}) // sets data to false in demandToModify"
    ],
    "lineNumber": 252,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "targetDemand",
        "description": "The targeted demand an which a specific demand type should be removed"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "restrictiveDemand",
        "description": "The demand which should be set to false in the targetDemand"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/Identity.js",
    "memberof": null,
    "longname": "libs/modules/Identity.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\n\n/**\n * @class\n * @desc This class represents an identity.\n * The identity is the view of the WONDER framework of a user's representation\n * and will be filled with information coming from the identity provider.\n */\nclass Identity {\n  /**\n   * @constructor\n   * @param {String} rtcIdentity - The username including the domain part of the identity which must be unique\n   * @param {String} remoteIdp - The URL of the remote identity provider\n   * @param {MessagingStub} msgStub - The messaging stub instance which will be used to connect the identity to its domain\n   * @param {String} msgStubUrl - The URL to the origin of the messaging stub\n   * @param {String} msgSrv - The URL to the messaging server which will be used for the identity's domain\n   * @param {Object} [codecs] - An array containing the codec URLs for the data channel\n   * @param {Object} [credentials] - An object containing credentials for the identity; can contain login information for the messaging server\n   */\n  constructor(rtcIdentity, remoteIdp, msgStub, msgStubUrl, msgSrv, codecs, credentials) {\n    /**\n     * @type {String} rtcIdentity\n     * @desc The username including the domain of the Identity\n     * @example alice@example.com\n     */\n    this.rtcIdentity = rtcIdentity;\n\n    /**\n     * @type {String} remoteIdp\n     * @desc The URL to the remote Idp\n     * @example 'webfinger' // recommended\n     * 'http://example.net/idp.php?user='\n     */\n    this.remoteIdp = remoteIdp;\n\n    /**\n     * @type {MessagingStub} msgStub\n     * @desc The instance of the messaging stub of the identity's domain\n     * which will be used to connect the identity to it's messaging server;\n     * it will also be used to communicate with the messaging server\n     * @example\n     * define(function(require, exports, module) {\n     *   class MessagingStubOfExampleDomain {\n     *     constructor() {\n     *       this.onMessage = null; // message event handler will use this to register itself on the stub\n     *     }\n     *     connect(rtcIdentity, credentials, msgSrv, callback) {\n     *       // ...\n     *       this.websocket.onmessage = function(msg) {\n     *         // ...\n     *         that.onMessage(msg); // give the message as a JSON-object to the registered function to process it in wonder\n     *       };\n     *       // ...\n     *     }\n     *     sendMessage(message) { ... }\n     *     disconnect() { ... }\n     *   }\n     *   return new MessagingStubOfExampleDomain();\n     * });\n     */\n    this.msgStub = msgStub;\n\n    /**\n     * @type {String} msgStubUrl\n     * @desc The URL to the location where the messagingStub was downloaded from\n     * @example 'http://example.net:8082/stubsDirectory/MessagingStubOfExampleDomain.js'\n     */\n    this.msgStubUrl = msgStubUrl;\n\n    /**\n     * @type {String} msgSrv\n     * @desc The URL to the messaging server of the identity's domain\n     * @example 'ws://example.org:12345'\n     */\n    this.msgSrv = msgSrv;\n\n    /**\n     * @type {Object} codecs\n     * @desc An object containing payloadtypes as keys to the links of codec libraries\n     * @example\n     * { chat: \"http://example.net:8083/codecs/chat.js\"\n     *   file: \"http://example.net:8083/codecs/file.js\" }\n     */\n    this.codecs = codecs;\n\n    /**\n     * @type {Object} [credentials]\n     * @desc An object containing credentials for the identity;\n     * can be used to be able to login to the identity's messaging server\n     * @example // ims login example\n     * { \"privid\" : \"identifier@subdomain.example.org:1234\",\n     *   \"pubid\" : \"pudIdentifier\",\n     *   \"proxy\" : \"10.11.12.13:12333\",\n     *   \"pwd\" : \"userPassword\"                              }\n     */\n    this.credentials = credentials;\n  }\n}\n"
  },
  {
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Identity",
    "memberof": "libs/modules/Identity.js",
    "longname": "libs/modules/Identity.js~Identity",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/modules/Identity.js",
    "importStyle": null,
    "description": "This class represents an identity.\nThe identity is the view of the WONDER framework of a user's representation\nand will be filled with information coming from the identity provider.",
    "lineNumber": 17,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "libs/modules/Identity.js~Identity",
    "longname": "libs/modules/Identity.js~Identity#constructor",
    "access": null,
    "description": null,
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "rtcIdentity",
        "description": "The username including the domain part of the identity which must be unique"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "remoteIdp",
        "description": "The URL of the remote identity provider"
      },
      {
        "nullable": null,
        "types": [
          "MessagingStub"
        ],
        "spread": false,
        "optional": false,
        "name": "msgStub",
        "description": "The messaging stub instance which will be used to connect the identity to its domain"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "msgStubUrl",
        "description": "The URL to the origin of the messaging stub"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "msgSrv",
        "description": "The URL to the messaging server which will be used for the identity's domain"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "codecs",
        "description": "An array containing the codec URLs for the data channel"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "credentials",
        "description": "An object containing credentials for the identity; can contain login information for the messaging server"
      }
    ],
    "generator": false
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "rtcIdentity",
    "memberof": "libs/modules/Identity.js~Identity",
    "longname": "libs/modules/Identity.js~Identity#rtcIdentity",
    "access": null,
    "description": "The username including the domain of the Identity",
    "examples": [
      "alice@example.com"
    ],
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "remoteIdp",
    "memberof": "libs/modules/Identity.js~Identity",
    "longname": "libs/modules/Identity.js~Identity#remoteIdp",
    "access": null,
    "description": "The URL to the remote Idp",
    "examples": [
      "'webfinger' // recommended\n'http://example.net/idp.php?user='"
    ],
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "msgStub",
    "memberof": "libs/modules/Identity.js~Identity",
    "longname": "libs/modules/Identity.js~Identity#msgStub",
    "access": null,
    "description": "The instance of the messaging stub of the identity's domain\nwhich will be used to connect the identity to it's messaging server;\nit will also be used to communicate with the messaging server",
    "examples": [
      "define(function(require, exports, module) {\n  class MessagingStubOfExampleDomain {\n    constructor() {\n      this.onMessage = null; // message event handler will use this to register itself on the stub\n    }\n    connect(rtcIdentity, credentials, msgSrv, callback) {\n      // ...\n      this.websocket.onmessage = function(msg) {\n        // ...\n        that.onMessage(msg); // give the message as a JSON-object to the registered function to process it in wonder\n      };\n      // ...\n    }\n    sendMessage(message) { ... }\n    disconnect() { ... }\n  }\n  return new MessagingStubOfExampleDomain();\n});"
    ],
    "lineNumber": 69,
    "type": {
      "nullable": null,
      "types": [
        "MessagingStub"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "msgStubUrl",
    "memberof": "libs/modules/Identity.js~Identity",
    "longname": "libs/modules/Identity.js~Identity#msgStubUrl",
    "access": null,
    "description": "The URL to the location where the messagingStub was downloaded from",
    "examples": [
      "'http://example.net:8082/stubsDirectory/MessagingStubOfExampleDomain.js'"
    ],
    "lineNumber": 76,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "msgSrv",
    "memberof": "libs/modules/Identity.js~Identity",
    "longname": "libs/modules/Identity.js~Identity#msgSrv",
    "access": null,
    "description": "The URL to the messaging server of the identity's domain",
    "examples": [
      "'ws://example.org:12345'"
    ],
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "codecs",
    "memberof": "libs/modules/Identity.js~Identity",
    "longname": "libs/modules/Identity.js~Identity#codecs",
    "access": null,
    "description": "An object containing payloadtypes as keys to the links of codec libraries",
    "examples": [
      "{ chat: \"http://example.net:8083/codecs/chat.js\"\n  file: \"http://example.net:8083/codecs/file.js\" }"
    ],
    "lineNumber": 92,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "credentials",
    "memberof": "libs/modules/Identity.js~Identity",
    "longname": "libs/modules/Identity.js~Identity#credentials",
    "access": null,
    "description": "An object containing credentials for the identity;\ncan be used to be able to login to the identity's messaging server",
    "examples": [
      "// ims login example\n{ \"privid\" : \"identifier@subdomain.example.org:1234\",\n  \"pubid\" : \"pudIdentifier\",\n  \"proxy\" : \"10.11.12.13:12333\",\n  \"pwd\" : \"userPassword\"                              }"
    ],
    "lineNumber": 104,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/Idp.js",
    "memberof": null,
    "longname": "libs/modules/Idp.js",
    "access": null,
    "description": null,
    "lineNumber": 10,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Steffen Druesedow <Steffen.Druesedow@telekom.de>\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n\n'use strict';\n\n/**\n * @class\n * @desc This class is the central class for resolving identities and exists only once in each wonder instance.\n * The Idp is a singleton object, there will always be just one instance of it, no matter how often the constructor is called.\n */\nclass Idp {\n  /**\n   * @constructor\n   * @param {String} [remoteIdp] - The url string to a remote Idp.\n   * @param {Identity} [myIdentity] - The own Identity\n   */\n  constructor(remoteIdp, myIdentity) {\n    /**\n     * @type {String|Object} remoteIdp\n     * @desc The url string to a remote Idp or an string for a well-known IdP like 'webfinger'. Default: webfinger\n     */\n    this.remoteIdp = remoteIdp || 'webfinger';\n\n    /**\n     * @type {Array<Identity>} resolvedIdentities\n     * @desc containing already known identities.\n     */\n    this.resolvedIdentities = [];\n\n    /**\n     * @type {String} messagingServer\n     * @desc contains the url to the messaging server, which is received from the remote Idp.\n     */\n    this.messagingServer = null;\n\n    /**\n     * @type {Identity} myIdentity\n     * @desc contains the identity of the local user\n     */\n    this.myIdentity = myIdentity;\n  }\n\n\n  /**\n   * @desc Return an Identity by searching resolved ones XOR resolve them on the fly\n   * @param {String} rtcIdentity - identity identifier to resolve an identity\n   * @param {Object} credentials - additional credentials of the identity\n   * @return {Promise<Identity>}\n   */\n  getIdentity(rtcIdentity, credentials) {\n    var that = this;\n\n    return new Promise(function(resolve, reject) {\n      if (!rtcIdentity) reject(new Error('[Idp getIdentity] no rtcIdentity parameter'));\n\n      // return the resolved identity if it exists\n      for (var i = 0; i < that.resolvedIdentities.length; i++) {\n        if (that.resolvedIdentities[i].rtcIdentity === rtcIdentity) {\n          console.log('[Idp getIdentity] identity already exists in:', that.resolvedIdentities);\n          resolve(that.resolvedIdentities[i]);\n          return; // needs to be here because resolve isn't leaving the function\n        }\n      }\n\n\n      // otherwise ask the remote idp\n      that.askRemoteIdp(rtcIdentity, credentials)\n        // both remote idp and msg download server answered correctly\n        .then(function(identity) {\n          if (identity) resolve(identity);\n          else reject(new Error('[Idp getIdentity] no identity resolved from remote idp'));\n        })\n        // an error was thrown, possibly due to the network\n        .catch(function(error) {\n          reject(error);\n        });\n\n    });\n  }\n\n\n\n  /**\n   * @desc Resolve an identity by asking the remote idp for information\n   * @param {String} rtcIdentity - Identity identifier to resolve an identity from the remote idp\n   * @param {Object} credentials - additional credentials of the identity\n   * @return {Promise<Identity>}\n   */\n  askRemoteIdp(rtcIdentity, credentials) {\n    var that = this;\n    var localMsgStubUrl = null;\n    var remoteMsgStubUrl = null;\n    var messagingServer = null;\n    var remoteMessagingServer = null;\n    var codecs = {};\n\n    return new Promise(function(resolve, reject) {\n      if (!rtcIdentity) reject(new Error('[Idp askRemoteIdp] no rtcIdentity in parameter'));\n      console.log('[Idp askRemoteIdp] asking remote Idp...');\n\n      if (that.remoteIdp === 'webfinger') {\n        require(['webfinger'], function() {\n          askWebFinger();\n        }, function(error) {\n          reject(new Error('[Idp askRemoteIdp] webfinger not found', error));\n        });\n      } else askJsonpIdp();\n\n\n      /**\n       * askWebFinger will search for identities using the webfinger protocol\n       */\n      function askWebFinger() {\n        // using the webfinger class\n        var webfinger = new WebFinger({\n          webfist_fallback: false, // defaults to false, fallback to webfist\n          tls_only: false, // defaults to true\n          uri_fallback: true, // defaults to false\n          request_timeout: 10000, // defaults to 10000\n        });\n\n        webfinger.lookup(rtcIdentity, function(err, data) {\n          if (err) {\n            reject((new Error('[Idp askRemoteIdp] error: ', err.message)));\n          } else {\n            console.log('[Idp askRemoteIdp] found Webfinger entry for ' + rtcIdentity + ': ', data);\n\n            /**\n             * get the MessagingStub URL's\n             * possibly there are different URL's for local and remote stubs depending on the domain\n             */\n            for (var val in data.object.properties) {\n              if (data.object.properties[val] === 'localStub') localMsgStubUrl = val;\n              if (data.object.properties[val] === 'remoteStub') remoteMsgStubUrl = val;\n              if (data.object.properties[val] === 'messagingServer') messagingServer = val;\n              if (data.object.properties[val] === 'messagingServer_remote') remoteMessagingServer = val;\n              if (data.object.properties[val].substr(0, 5) == 'codec') {\n                var codecKey = data.object.properties[val].substr(6); // cut 'codec_'\n                codecs[codecKey] = val;\n              }\n            };\n            console.log('[Idp askRemoteIdp] extracted codec URIs', codecs);\n\n            if ( remoteMsgStubUrl && remoteMessagingServer ) {\n                var localDomain = that.myIdentity.split(\"@\")[1];\n                var requestedDomain = rtcIdentity.split(\"@\")[1];\n                if ( localDomain != requestedDomain ) {\n                    console.log(\"[Idp askRemoteIdp] using remote MsgStub '\" + remoteMsgStubUrl + \"' for identity: \" + rtcIdentity );\n                    localMsgStubUrl = remoteMsgStubUrl;\n                    messagingServer = remoteMessagingServer;\n                }\n            }\n\n            that.getMsgStub(localMsgStubUrl)\n              // successfully resolved the messaging stub\n              .then(function(msgStub) {\n                var identity = new Identity(rtcIdentity, that.remoteIdp, msgStub, localMsgStubUrl, messagingServer, codecs, credentials);\n                that.resolvedIdentities.push(identity); // store identity in array\n                resolve(identity); // return the identity\n              })\n              // failed to resolve the messaging stub\n              .catch(function(error) {\n                reject(error);\n              });\n          }\n        });\n      }\n\n\n      /**\n       * askOtherIdp is trying to connect to an IdP using the given IdP-options\n       */\n      function askJsonpIdp() {\n        require([that.remoteIdp + rtcIdentity],\n          // successfully received the identity\n          function(data) {\n            console.log('[Idp askJsonpIdp] remote idp answered: ', data);\n            localMsgStubUrl = data.rows[0].messagingStubURL;\n            messagingServer = data.rows[0].messagingServer;\n            codecs = {};\n\n            for (val in data.rows[0]) {\n              if (val.substr(0, 5) === 'codec') {\n                var codecKey = val.substr(6); // cut 'codec_'\n                codecs[codecKey] = data.rows[0][val];\n                console.log('[Idp askRemoteIdp] extracted codec URIs', codecs);\n              }\n            }\n\n            that.getMsgStub(localMsgStubUrl)\n              // successfully resolved the messaging stub\n              .then(function(msgStub) {\n                var identity = new Identity(rtcIdentity, that.remoteIdp, msgStub, localMsgStubUrl, messagingServer, codecs, credentials);\n                that.resolvedIdentities.push(identity); // store identity in the idp\n                resolve(identity); // return the identity\n              })\n              // failed to resolve the messaging stub\n              .catch(function(error) {\n                reject(new Error('[Idp askJsonpIdp] the messaging stub could not be loaded for ' + rtcIdentity + ': ', error));\n              });\n          },\n          // failed to receive the identity\n          function(error) {\n            reject(new Error('[Idp askJsonpIdp] the identity could not be resolved from remote idp: ', error));\n          }\n        );\n      }\n\n\n    });\n  }\n\n\n\n  /**\n   * @desc Resolve a messaging stub by asking a stub providing server\n   * @param {string} localMsgStubUrl - URL to a messaging stub for a specific messaging server\n   * @return {MessagingStub}\n   */\n  getMsgStub(localMsgStubUrl) {\n    var that = this;\n    console.log('[Idp getMsgStub] asking stub server for an implementation: ', localMsgStubUrl);\n\n    return new Promise(function(resolve, reject) {\n      require([localMsgStubUrl],\n        // successfully received the messaging stub\n        function(msgStub) {\n          console.log('[Idp getMsgStub] received stub: ', msgStub);\n          resolve(msgStub);\n        },\n        // messaging stub download failed\n        function(error) {\n          reject(Error('[Idp getMsgStub] messaging stub could not be retrieved from URL; possibly a malformed URL or the server is unreachable: ', error));\n        }\n      );\n    });\n  }\n}\n"
  },
  {
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Idp",
    "memberof": "libs/modules/Idp.js",
    "longname": "libs/modules/Idp.js~Idp",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/modules/Idp.js",
    "importStyle": null,
    "description": "This class is the central class for resolving identities and exists only once in each wonder instance.\nThe Idp is a singleton object, there will always be just one instance of it, no matter how often the constructor is called.",
    "lineNumber": 17,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "libs/modules/Idp.js~Idp",
    "longname": "libs/modules/Idp.js~Idp#constructor",
    "access": null,
    "description": null,
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "remoteIdp",
        "description": "The url string to a remote Idp."
      },
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": true,
        "name": "myIdentity",
        "description": "The own Identity"
      }
    ],
    "generator": false
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "remoteIdp",
    "memberof": "libs/modules/Idp.js~Idp",
    "longname": "libs/modules/Idp.js~Idp#remoteIdp",
    "access": null,
    "description": "The url string to a remote Idp or an string for a well-known IdP like 'webfinger'. Default: webfinger",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "String",
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "resolvedIdentities",
    "memberof": "libs/modules/Idp.js~Idp",
    "longname": "libs/modules/Idp.js~Idp#resolvedIdentities",
    "access": null,
    "description": "containing already known identities.",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "Array<Identity>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "messagingServer",
    "memberof": "libs/modules/Idp.js~Idp",
    "longname": "libs/modules/Idp.js~Idp#messagingServer",
    "access": null,
    "description": "contains the url to the messaging server, which is received from the remote Idp.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "myIdentity",
    "memberof": "libs/modules/Idp.js~Idp",
    "longname": "libs/modules/Idp.js~Idp#myIdentity",
    "access": null,
    "description": "contains the identity of the local user",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "Identity"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getIdentity",
    "memberof": "libs/modules/Idp.js~Idp",
    "longname": "libs/modules/Idp.js~Idp#getIdentity",
    "access": null,
    "description": "Return an Identity by searching resolved ones XOR resolve them on the fly",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "rtcIdentity",
        "description": "identity identifier to resolve an identity"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "credentials",
        "description": "additional credentials of the identity"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Identity>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "askRemoteIdp",
    "memberof": "libs/modules/Idp.js~Idp",
    "longname": "libs/modules/Idp.js~Idp#askRemoteIdp",
    "access": null,
    "description": "Resolve an identity by asking the remote idp for information",
    "lineNumber": 95,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "rtcIdentity",
        "description": "Identity identifier to resolve an identity from the remote idp"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "credentials",
        "description": "additional credentials of the identity"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Identity>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getMsgStub",
    "memberof": "libs/modules/Idp.js~Idp",
    "longname": "libs/modules/Idp.js~Idp#getMsgStub",
    "access": null,
    "description": "Resolve a messaging stub by asking a stub providing server",
    "lineNumber": 226,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "localMsgStubUrl",
        "description": "URL to a messaging stub for a specific messaging server"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MessagingStub"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/Message.js",
    "memberof": null,
    "longname": "libs/modules/Message.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\n/**\n * @class\n * @desc This class is a data holder for all messages that are sent between two WONDER implementations.\n * @desc The messages must be in that format when they arrive at another WONDER instance\n * and therefore need to be preserved while being sent through a messaging server.\n * @example var message = new Message(from, to, MessageType.invitation, conversationId, misc);\n */\nclass Message {\n  /**\n   * @constructor\n   * @param {Identity} from - The identity from which the message will be or was sent\n   * @param {(Identity|Array<Identity>)} to - The identity or identities that will receive the message\n   * @param {String} type - The type of the message which is a shortform of the intention or action of the message\n   * @param {GUID} conversationId - A unique ID for the conversation the message is related to\n   * @param {Object} [misc] - Additional information related to the type of the message.\n   */\n  constructor(from, to, type, conversationId, misc) {\n    /**\n     * @type {GUID} id\n     * @desc A unique ID for the message to be able to distinguish messages\n     */\n    this.id = guid();\n\n    /**\n     * @type {Identity} from\n     * @desc The identity from which the message will be or was sent\n     */\n    this.from = from;\n\n    /**\n     * @type {Identity|Array<Identity>} to\n     * @desc The target identity or identities to receive the message\n     */\n    this.to = to;\n\n    /**\n     * @type {MessageType} type\n     * @desc Type of the message which must be one of the types defined in MessageType\n     * @example MessageType.invitation\n     */\n    this.type = type;\n\n    /**\n     * @type {GUID} conversationId\n     * @desc The unique id of the conversation, the message is related to\n     */\n    this.conversationId = conversationId;\n\n    /**\n     * @type {object} misc\n     * @desc Additional information related to the type of the message\n     * @example { 'demand': demand,\n     *            'sessionDescription': sessionDescription }\n     */\n    this.misc = misc;\n  }\n}\n"
  },
  {
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Message",
    "memberof": "libs/modules/Message.js",
    "longname": "libs/modules/Message.js~Message",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/modules/Message.js",
    "importStyle": null,
    "description": "The messages must be in that format when they arrive at another WONDER instance\nand therefore need to be preserved while being sent through a messaging server.",
    "examples": [
      "var message = new Message(from, to, MessageType.invitation, conversationId, misc);"
    ],
    "lineNumber": 17,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "libs/modules/Message.js~Message",
    "longname": "libs/modules/Message.js~Message#constructor",
    "access": null,
    "description": null,
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The identity from which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "Identity",
          "Array<Identity>"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The identity or identities that will receive the message"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type of the message which is a shortform of the intention or action of the message"
      },
      {
        "nullable": null,
        "types": [
          "GUID"
        ],
        "spread": false,
        "optional": false,
        "name": "conversationId",
        "description": "A unique ID for the conversation the message is related to"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "misc",
        "description": "Additional information related to the type of the message."
      }
    ],
    "generator": false
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "id",
    "memberof": "libs/modules/Message.js~Message",
    "longname": "libs/modules/Message.js~Message#id",
    "access": null,
    "description": "A unique ID for the message to be able to distinguish messages",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "GUID"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "from",
    "memberof": "libs/modules/Message.js~Message",
    "longname": "libs/modules/Message.js~Message#from",
    "access": null,
    "description": "The identity from which the message will be or was sent",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "Identity"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "to",
    "memberof": "libs/modules/Message.js~Message",
    "longname": "libs/modules/Message.js~Message#to",
    "access": null,
    "description": "The target identity or identities to receive the message",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "Identity",
        "Array<Identity>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "type",
    "memberof": "libs/modules/Message.js~Message",
    "longname": "libs/modules/Message.js~Message#type",
    "access": null,
    "description": "Type of the message which must be one of the types defined in MessageType",
    "examples": [
      "MessageType.invitation"
    ],
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "MessageType"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "conversationId",
    "memberof": "libs/modules/Message.js~Message",
    "longname": "libs/modules/Message.js~Message#conversationId",
    "access": null,
    "description": "The unique id of the conversation, the message is related to",
    "lineNumber": 56,
    "type": {
      "nullable": null,
      "types": [
        "GUID"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "misc",
    "memberof": "libs/modules/Message.js~Message",
    "longname": "libs/modules/Message.js~Message#misc",
    "access": null,
    "description": "Additional information related to the type of the message",
    "examples": [
      "{ 'demand': demand,\n           'sessionDescription': sessionDescription }"
    ],
    "lineNumber": 64,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/MessageFactory.js",
    "memberof": null,
    "longname": "libs/modules/MessageFactory.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\n/**\n * @class\n * @desc This class creates WONDER-compliant messages.\n * Please note that all functions in this class are static,\n * so there is no need to create MessageFactory objects.\n */\nclass MessageFactory {\n  /**\n   * @constructor\n   */\n  constructor() {}\n    /**\n     * @desc Creates an invitation message\n     * @param {Identity} from - The identity from which the message will be or was sent\n     * @param {Identity|Array<Identity>} to - The identity to which the message will be or was sent\n     * @param {GUID} conversationId - The conversationId of the conversation which is related to the invitation\n     * @param {Object} demand - The demanded resources for the conversation\n     * @param {Object} sessionDescription - The local description \"offer\" of the peer connection on the invitation sender's end\n     * @return {Message}\n     * @example MessageFactory.invitation(from, to, conversationId, demand, sessionDescription);\n     */\n  static invitation(from, to, conversationId, demand, sessionDescription) {\n    if (!(from instanceof Identity)) return new Error('[MessageFactory.invitation] from should be an instance of Identity');\n    if (!(to instanceof Identity || (typeof to == 'array' || to instanceof Array) && !to.find(function(i) {\n        return !(i instanceof Identity)\n      }))) return new Error('[MessageFactory.invitation] to should be an instance of Identity or an Array with Identities');\n    if (!(typeof conversationId == 'string' || conversationId instanceof String)) return new Error('[MessageFactory.invitation] conversationId should be a string');\n    if (!(typeof demand == 'object' || demand instanceof Object)) return new Error('[MessageFactory.invitation] demand should be an object');\n\n    var misc = {\n      'demand': demand,\n      'sessionDescription': sessionDescription\n    }\n    return new Message(from, to, MessageType.invitation, conversationId, misc);\n  }\n\n\n\n  /**\n   * @desc Creates a message to accept an invitation\n   * @param {Identity} from - The identity from which the message will be or was sent\n   * @param {Identity|Array<Identity>} to - The identity to which the message will be or was sent\n   * @param {GUID} conversationId - The conversationId of the conversation which is related to the invitation\n   * @param {Object} demand - The demanded resources for the conversation\n   * @param {Object} sessionDescription - The local description \"answer\" of the peer connection on the invitation reveiving end\n   * @return {Message}\n   * @example MessageFactory.accepted(from, to, conversationId, demand, sessionDescription);\n   */\n  static accepted(from, to, conversationId, demand, sessionDescription) {\n    if (!(from instanceof Identity)) return new Error('[MessageFactory.accepted] from should be an instance of Identity');\n    if (!(to instanceof Identity || (typeof to == 'array' || to instanceof Array) && !to.find(function(i) {\n        return !(i instanceof Identity)\n      }))) return new Error('[MessageFactory.accepted] to should be an instance of Identity or an Array with Identities');\n    if (!(typeof conversationId == 'string' || conversationId instanceof String)) return new Error('[MessageFactory.accepted] conversationId should be a string');\n    if (!(typeof demand == 'object' || demand instanceof Object)) return new Error('[MessageFactory.accepted] demand should be an object');\n\n    var misc = {\n      'demand': demand,\n      'sessionDescription': sessionDescription\n    }\n    return new Message(from, to, MessageType.accepted, conversationId, misc);\n  }\n\n\n\n  /**\n   * @desc Creates a message to decline an invitation\n   * @param {Identity} from - The identity from which the message will be or was sent\n   * @param {Identity|Array<Identity>} to - The identity to which the message will be or was sent\n   * @param {GUID} conversationId - The conversationId of the conversation which is related to the invitation\n   * @example MessageFactory.declined(from, to, conversationId);\n   * @return {Message}\n   */\n  static declined(from, to, conversationId) {\n    console.log(from, to, conversationId);\n    if (!(from instanceof Identity)) return new Error('[MessageFactory.declined] from should be an instance of Identity');\n    if (!(to instanceof Identity || (typeof to == 'array' || to instanceof Array) && !to.find(function(i) {\n        return !(i instanceof Identity)\n      }))) return new Error('[MessageFactory.declined] to should be an instance of Identity or an Array with Identities');\n    if (!(typeof conversationId == 'string' || conversationId instanceof String)) return new Error('[MessageFactory.declined] conversationId should be a string');\n\n    return new Message(from, to, MessageType.declined, conversationId);\n  }\n\n\n\n  /**\n   * @desc Creates a message to end a conversation\n   * @param {Identity} from - The identity from which the message will be or was sent\n   * @param {Identity|Array<Identity>} to - The identity to which the message will be or was sent\n   * @param {GUID} conversationId - The conversationId of the conversation which is related to the invitation\n   * @example MessageFactory.bye(from, to, conversationId);\n   * @return {Message}\n   */\n  static bye(from, to, conversationId) {\n    if (!(from instanceof Identity)) return new Error('[MessageFactory.bye] from should be an instance of Identity');\n    if (!(to instanceof Identity || (typeof to == 'array' || to instanceof Array) && !to.find(function(i) {\n        return !(i instanceof Identity)\n      }))) return new Error('[MessageFactory.bye] to should be an instance of Identity or an Array with Identities');\n    if (!(typeof conversationId == 'string' || conversationId instanceof String)) return new Error('[MessageFactory.bye] conversationId should be a string');\n\n    return new Message(from, to, MessageType.bye, conversationId);\n  }\n\n\n  /**\n   * @desc Creates a message containing the new demand\n   * @param {Identity} from - The identity from which the message will be or was sent\n   * @param {Identity|Array<Identity>} to - The identity to which the message will be or was sent\n   * @param {GUID} conversationId - The conversationId of the conversation which is related to the invitation\n   * @param {Object} demand - The demanded resources for the conversation\n   * @example MessageFactory.updateConstraints(from, to, conversationId, demand);\n   * @return {Message}\n   * @TODO rename the message to updateDemand\n   */\n  static updateConstraints(from, to, conversationId, demand) {\n    if (!(from instanceof Identity)) return new Error('[MessageFactory.updateConstraints] from should be an instance of Identity');\n    if (!(to instanceof Identity || (typeof to == 'array' || to instanceof Array) && !to.find(function(i) {\n        return !(i instanceof Identity)\n      }))) return new Error('[MessageFactory.updateConstraints] to should be an instance of Identity or an Array with Identities');\n    if (!(typeof conversationId == 'string' || conversationId instanceof String)) return new Error('[MessageFactory.updateConstraints] conversationId should be a string');\n    if (!(typeof demand == 'object' || demand instanceof Object)) return new Error('[MessageFactory.updateConstraints] demand should be an object');\n\n    var misc = {\n      'demand': demand,\n    }\n    return new Message(from, to, MessageType.update, conversationId, misc);\n  }\n\n\n\n  /**\n   * @desc Creates an message to update ICE candidates of a peer connection\n   * @param {Identity} from - The identity from which the message will be or was sent\n   * @param {Identity|Array<Identity>} to - The identity to which the message will be or was sent\n   * @param {GUID} conversationId - The conversationId of the conversation which is related to the invitation\n   * @param {Object} iceCandidates - An object containing new ICE candidates (STUN, TURN)\n   * @example MessageFactory.updateIceCandidates(from, to, conversationId, iceCandidates);\n   * @return {Message}\n   */\n  static updateIceCandidates(from, to, conversationId, iceCandidates) {\n    if (!(from instanceof Identity)) return new Error('[MessageFactory.updateIceCandidates] from should be an instance of Identity');\n    if (!(to instanceof Identity || (typeof to == 'array' || to instanceof Array) && !to.find(function(i) {\n        return !(i instanceof Identity)\n      }))) return new Error('[MessageFactory.updateIceCandidates] to should be an instance of Identity or an Array with Identities');\n    if (!(typeof conversationId == 'string' || conversationId instanceof String)) return new Error('[MessageFactory.updateIceCandidates] conversationId should be a string');\n\n    return new Message(from, to, MessageType.connectivityCandidate, conversationId, iceCandidates);\n  }\n\n\n  /**\n   * @desc Creates a message containing the new session description\n   * @param {Identity} from - The identity from which the message will be or was sent\n   * @param {Identity|Array<Identity>} to - The identity to which the message will be or was sent\n   * @param {GUID} conversationId - The conversationId of the conversation which is related to the invitation\n   * @param {Object} sdp - The SDP object of the peer connection\n   * @example MessageFactory.updateSdp(from, to, conversationId, sdp);\n   * @return {Message}\n   */\n  static updateSdp(from, to, conversationId, sdp) {\n    if (!(from instanceof Identity)) return new Error('[MessageFactory.updateConstraints] from should be an instance of Identity');\n    if (!(to instanceof Identity || (typeof to == 'array' || to instanceof Array) && !to.find(function(i) {\n        return !(i instanceof Identity)\n      }))) return new Error('[MessageFactory.updateConstraints] to should be an instance of Identity or an Array with Identities');\n    if (!(typeof conversationId == 'string' || conversationId instanceof String)) return new Error('[MessageFactory.updateConstraints] conversationId should be a string');\n    //if( !(typeof sdp == 'object' || demand instanceof Object) ) return new Error('[MessageFactory.updateConstraints] demand should be an object');\n\n    var misc = {\n      'sdp': sdp,\n    }\n    return new Message(from, to, MessageType.updateSdp, conversationId, misc);\n  }\n\n\n\n  /**\n   * @desc Creates a message to announce the current presence status\n   * @param {Identity} from - The identity from which the message will be or was sent\n   * @param {Identity|Array<Identity>} to - The identity to which the message will be or was sent\n   * @param {GUID} conversationId - The conversationId of the conversation which is related to the invitation\n   * @param {string} status - The presence state of the identity from which the message is sent\n   * @example MessageFactory.presence(from, to, conversationId, status);\n   * @return {Message}\n   * @TODO use it in the communication\n   */\n  static presence(from, to, conversationId, status) {\n    if (!(from instanceof Identity)) return new Error('[MessageFactory.presence] from should be an instance of Identity');\n    if (!(to instanceof Identity || (typeof to == 'array' || to instanceof Array) && !to.find(function(i) {\n        return !(i instanceof Identity)\n      }))) return new Error('[MessageFactory.presence] to should be an instance of Identity or an Array with Identities');\n    if (!(typeof conversationId == 'string' || conversationId instanceof String)) return new Error('[MessageFactory.presence] conversationId should be a string');\n\n    return new Message(from, to, MessageType.presence, conversationId);\n  }\n\n}\n"
  },
  {
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "MessageFactory",
    "memberof": "libs/modules/MessageFactory.js",
    "longname": "libs/modules/MessageFactory.js~MessageFactory",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/modules/MessageFactory.js",
    "importStyle": null,
    "description": "This class creates WONDER-compliant messages.\nPlease note that all functions in this class are static,\nso there is no need to create MessageFactory objects.",
    "lineNumber": 16,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "libs/modules/MessageFactory.js~MessageFactory",
    "longname": "libs/modules/MessageFactory.js~MessageFactory#constructor",
    "access": null,
    "description": null,
    "lineNumber": 20,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [],
    "generator": false
  },
  {
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "invitation",
    "memberof": "libs/modules/MessageFactory.js~MessageFactory",
    "longname": "libs/modules/MessageFactory.js~MessageFactory.invitation",
    "access": null,
    "description": "Creates an invitation message",
    "examples": [
      "MessageFactory.invitation(from, to, conversationId, demand, sessionDescription);"
    ],
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The identity from which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "Identity",
          "Array<Identity>"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The identity to which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "GUID"
        ],
        "spread": false,
        "optional": false,
        "name": "conversationId",
        "description": "The conversationId of the conversation which is related to the invitation"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "demand",
        "description": "The demanded resources for the conversation"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "sessionDescription",
        "description": "The local description \"offer\" of the peer connection on the invitation sender's end"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Message"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "accepted",
    "memberof": "libs/modules/MessageFactory.js~MessageFactory",
    "longname": "libs/modules/MessageFactory.js~MessageFactory.accepted",
    "access": null,
    "description": "Creates a message to accept an invitation",
    "examples": [
      "MessageFactory.accepted(from, to, conversationId, demand, sessionDescription);"
    ],
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The identity from which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "Identity",
          "Array<Identity>"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The identity to which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "GUID"
        ],
        "spread": false,
        "optional": false,
        "name": "conversationId",
        "description": "The conversationId of the conversation which is related to the invitation"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "demand",
        "description": "The demanded resources for the conversation"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "sessionDescription",
        "description": "The local description \"answer\" of the peer connection on the invitation reveiving end"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Message"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "declined",
    "memberof": "libs/modules/MessageFactory.js~MessageFactory",
    "longname": "libs/modules/MessageFactory.js~MessageFactory.declined",
    "access": null,
    "description": "Creates a message to decline an invitation",
    "examples": [
      "MessageFactory.declined(from, to, conversationId);"
    ],
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The identity from which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "Identity",
          "Array<Identity>"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The identity to which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "GUID"
        ],
        "spread": false,
        "optional": false,
        "name": "conversationId",
        "description": "The conversationId of the conversation which is related to the invitation"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Message"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "bye",
    "memberof": "libs/modules/MessageFactory.js~MessageFactory",
    "longname": "libs/modules/MessageFactory.js~MessageFactory.bye",
    "access": null,
    "description": "Creates a message to end a conversation",
    "examples": [
      "MessageFactory.bye(from, to, conversationId);"
    ],
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The identity from which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "Identity",
          "Array<Identity>"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The identity to which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "GUID"
        ],
        "spread": false,
        "optional": false,
        "name": "conversationId",
        "description": "The conversationId of the conversation which is related to the invitation"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Message"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "updateConstraints",
    "memberof": "libs/modules/MessageFactory.js~MessageFactory",
    "longname": "libs/modules/MessageFactory.js~MessageFactory.updateConstraints",
    "access": null,
    "description": "Creates a message containing the new demand",
    "examples": [
      "MessageFactory.updateConstraints(from, to, conversationId, demand);"
    ],
    "lineNumber": 125,
    "unknown": [
      {
        "tagName": "@TODO",
        "tagValue": "rename the message to updateDemand"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The identity from which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "Identity",
          "Array<Identity>"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The identity to which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "GUID"
        ],
        "spread": false,
        "optional": false,
        "name": "conversationId",
        "description": "The conversationId of the conversation which is related to the invitation"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "demand",
        "description": "The demanded resources for the conversation"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Message"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "updateIceCandidates",
    "memberof": "libs/modules/MessageFactory.js~MessageFactory",
    "longname": "libs/modules/MessageFactory.js~MessageFactory.updateIceCandidates",
    "access": null,
    "description": "Creates an message to update ICE candidates of a peer connection",
    "examples": [
      "MessageFactory.updateIceCandidates(from, to, conversationId, iceCandidates);"
    ],
    "lineNumber": 150,
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The identity from which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "Identity",
          "Array<Identity>"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The identity to which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "GUID"
        ],
        "spread": false,
        "optional": false,
        "name": "conversationId",
        "description": "The conversationId of the conversation which is related to the invitation"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "iceCandidates",
        "description": "An object containing new ICE candidates (STUN, TURN)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Message"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "updateSdp",
    "memberof": "libs/modules/MessageFactory.js~MessageFactory",
    "longname": "libs/modules/MessageFactory.js~MessageFactory.updateSdp",
    "access": null,
    "description": "Creates a message containing the new session description",
    "examples": [
      "MessageFactory.updateSdp(from, to, conversationId, sdp);"
    ],
    "lineNumber": 170,
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The identity from which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "Identity",
          "Array<Identity>"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The identity to which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "GUID"
        ],
        "spread": false,
        "optional": false,
        "name": "conversationId",
        "description": "The conversationId of the conversation which is related to the invitation"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "sdp",
        "description": "The SDP object of the peer connection"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Message"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "presence",
    "memberof": "libs/modules/MessageFactory.js~MessageFactory",
    "longname": "libs/modules/MessageFactory.js~MessageFactory.presence",
    "access": null,
    "description": "Creates a message to announce the current presence status",
    "examples": [
      "MessageFactory.presence(from, to, conversationId, status);"
    ],
    "lineNumber": 196,
    "unknown": [
      {
        "tagName": "@TODO",
        "tagValue": "use it in the communication"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "The identity from which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "Identity",
          "Array<Identity>"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "The identity to which the message will be or was sent"
      },
      {
        "nullable": null,
        "types": [
          "GUID"
        ],
        "spread": false,
        "optional": false,
        "name": "conversationId",
        "description": "The conversationId of the conversation which is related to the invitation"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "status",
        "description": "The presence state of the identity from which the message is sent"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Message"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/MsgEvtHandler.js",
    "memberof": null,
    "longname": "libs/modules/MsgEvtHandler.js",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Steffen Druesedow <Steffen.Druesedow@telekom.de>\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\n/**\n * @class\n * @desc This class is a handler for messages coming from a messaging server\n */\nclass MsgEvtHandler {\n  /**\n   * @constructor\n   * @param {WONDER} wonderInstance - The instance of wonder used as a backreference\n   * @param {Conversation} conversation - An reference to the related conversation\n   */\n  constructor(wonderInstance, conversation) {\n    /**\n     * @type {Conversation} conversation\n     * @desc An reference to the conversation the event handler is handling incoming messages for\n     */\n    this.conversation = conversation || null;\n\n    /**\n     * @type {Wonder} wonderInstance\n     * @desc Backreference to the wonder instance the message event handler is related to\n     */\n    this.wonderInstance = wonderInstance;\n\n    /**\n     * @type {Boolean} ice\n     * @desc Flag to be able to tell if ice handling is allowed and the session description exchange of the peer connections is over\n     */\n    this.ice = false;\n\n  }\n\n\n\n  /**\n   * @desc This is a function to handle all incoming messages from the messaging server.\n   * @param {Message} msg\n   * @example\n   * msgStubInstance.onMessage = conversation.msgEvtHandler.onMessage().bind(conversation.msgEvtHandler);\n   */\n  onMessage(msg) {\n    var that = this;\n    switch (msg.type) {\n\n      case MessageType.invitation:\n        if (that.conversation) { // if a conversation is attached to that message event handler\n          console.log(\"[MsgEvtHandler onMessage] conversation is already present\");\n          if (that.conversation.id == msg.conversationId) { // and the conversatinId is matching then add new constaints/fulfill the demand\n            console.log(\"[MsgEvtHandler onMessage] invitation is legit, updating conversation\");\n            that.wonderInstance.localIdp.getIdentity(msg.from)\n            .then(function(identity) {\n              var remoteParticipant = that.conversation.getRemoteParticipant(identity);\n\n              console.log(\"remote demand: \",msg.misc.demand);\n              // choose the right method\n              // did the remote user request audio or video\n              if (msg.misc.demand.in.video || msg.misc.demand.out.video ||\n                  msg.misc.demand.in.audio || msg.misc.demand.out.audio) {\n                // do i have such a connection already\n                console.log(\"remoteParticipant\", remoteParticipant);\n                console.log(\"myParticipant\", myParticipant);\n                //if (!remoteParticipant.demand.in.video && !remoteParticipant.demand.out.video &&\n                //    !remoteParticipant.demand.in.audio && !remoteParticipant.demand.out.audio)\n                  that.establishRtcConnection(that.wonderInstance, that.conversation, msg); // only establish the connection when video or audio hasnt been created\n              }\n              // create as many datachannels as the remote user wants\n              if (msg.misc.demand.in.data || msg.misc.demand.out.data) {\n                that.establishDataChannel(that.wonderInstance, that.conversation, msg);\n              }\n            })\n            .catch(function(error){\n              console.error(error);\n            });\n          } else {\n            console.error(\"Message arrived at wrong MessageEventHandler or MessageEventHandler is still registered on myParticipant instead of a remoteParticipant!\");\n          }\n        } else {\n          console.log(\"[MsgEvtHandler onMessage] invitation is legit, creating a new conversation\");\n          var conversation = new Conversation(that.wonderInstance);\n          var myParticipant = new Participant(that.wonderInstance, that.wonderInstance.myIdentity, new Demand(msg.misc.demand));\n          conversation.id = msg.conversationId; // when we receive an invitation an id is already present, so use it\n          conversation.myParticipant = myParticipant; // my local bob participant\n          conversation.msgSrv = that.wonderInstance.myIdentity.msgSrv; // use my messaging server as I have been called\n          conversation.msgStub = that.wonderInstance.myIdentity.msgStub; // copy my messaging stub to the conversation\n          conversation.msgEvthandler = that; // we also need to set this invitationhandler to the messaging handler of the conversation\n          conversation.msgStub.onMessage = conversation.msgEvtHandler.onMessage.bind(conversation.msgEvtHandler);\n\n          that.conversation = conversation; // reference it in the handler to use it in other functions\n          that.wonderInstance.conversations.push(conversation); // add the conversation to wonder\n\n          // get the remote identity\n          that.wonderInstance.localIdp.getIdentity(msg.from)\n          .then(function(identity) {\n            // Add participant and set the RTCPeerConnection\n            conversation.addRemoteParticipant(new Participant(that.wonderInstance, identity, msg.misc.demand));\n            conversation.myParticipant.setRtcPeerConnection(\n              new RTCPeerConnection({\n                iceServers: that.wonderInstance.config.ice\n              })\n            );\n\n            if(that.wonderInstance.config.autoAccept){\n              // choose the right method\n              // TODO: change this to be able to establish a audio/video and a data connection with one invitation\n              if (msg.misc.demand.in.data || msg.misc.demand.out.data) {\n                that.establishDataChannel(that.wonderInstance, conversation, msg);\n              } else {\n                that.establishRtcConnection(that.wonderInstance, conversation, msg);\n              }\n            }\n          })\n          .then(function(){\n            that.wonderInstance.onMessage(msg); // user interface for message events\n            return;\n          })\n          .catch(function(error) {\n            return error;\n          });\n        }\n        return; // needs to be here in order not to call onMessage twice\n        break;\n\n      case MessageType.accepted:\n        console.log('[MsgEvtHandler onMessage] accepted', msg);\n        that.conversation.myParticipant.peerConnection.setRemoteDescription(\n          new RTCSessionDescription(msg.misc.sessionDescription)\n        );\n\n        // tell bob that he can also start handling ice candidates now\n        var message = MessageFactory.updateIceCandidates(\n          that.conversation.myParticipant.identity,\n          that.conversation.remoteParticipants[0].identity,\n          that.conversation.id,\n          \"last\"\n        );\n        that.conversation.msgStub.sendMessage(message);\n        that.ice = true; // handle ice allowed for rtchandler\n\n        // and send all kept back ice candidates\n        for (var i = that.conversation.rtcEvtHandler.msgbuf.length - 1; i >= 0; i--) {\n          that.conversation.msgStub.sendMessage(that.conversation.rtcEvtHandler.msgbuf[i]);\n          that.conversation.rtcEvtHandler.msgbuf.splice(i, 1);\n        }\n\n        that.wonderInstance.onMessage(msg);\n        break;\n\n      case MessageType.declined:\n        console.log('[MsgEvtHandler onMessage] declined', msg);\n        that.wonderInstance.onMessage(msg);\n        break;\n\n      case MessageType.bye:\n        console.log('[MsgEvtHandler onMessage] bye', msg);\n        that.wonderInstance.onMessage(msg);\n        break;\n\n      case MessageType.update:\n        console.log('[MsgEvtHandler onMessage] update', msg);\n        that.wonderInstance.onMessage(msg);\n        break;\n\n      case MessageType.updateSdp:\n        console.log('[MsgEvtHandler onMessage] updateSdp', msg);\n        that.wonderInstance.onMessage(msg);\n        break;\n\n      case MessageType.updated:\n        console.log('[MsgEvtHandler onMessage] updated', msg);\n        that.wonderInstance.onMessage(msg);\n        break;\n\n      case MessageType.connectivityCandidate:\n        console.log('[MsgEvtHandler onMessage] connectivityCandidate', msg);\n        // we need to store the candidates because they can only be used when remotedesriptions are set\n        // if we handle them before we wont see a video but a frozen transparent black blob inside the video element\n        if (msg.misc == \"last\") { // send all candidates to alice\n          for (var i = that.conversation.rtcEvtHandler.msgbuf.length - 1; i >= 0; i--) {\n            that.conversation.msgStub.sendMessage(that.conversation.rtcEvtHandler.msgbuf[i]);\n            that.conversation.rtcEvtHandler.msgbuf.splice(i, 1);\n          }\n        } else { // if the last operation hasnt completed start adding candidates\n          that.conversation.myParticipant.peerConnection.addIceCandidate(new RTCIceCandidate(msg.misc));\n        }\n        that.wonderInstance.onMessage(msg);\n        break;\n\n      case MessageType.message:\n        console.log('[MsgEvtHandler onMessage] message', message);\n        that.wonderInstance.onMessage(msg);\n        break;\n\n      default:\n        console.log('[MsgEvtHandler onMessage] default', message);\n        that.wonderInstance.onMessage(msg);\n        break;\n    }\n  }\n\n\n\n  /**\n   * @desc This functions establishes a data channel for the invitation receiving side.\n   * It is only called from the message event handler itself and shouldn't be used outside of it.\n   * @param {WONDER} wonderInstance - The instance of the WONDER class used as a backreference\n   * @param {Conversation} conversation - An reference to the corresponding conversation\n   * @param {Message} msg - The invitation message received\n   */\n  establishDataChannel(wonderInstance, conversation, msg) {\n    var that = this;\n    console.log(\"conversation:\",conversation);\n    if (conversation.dataChannelEvtHandler && conversation.dataChannelEvtHandler instanceof DataChannelEvtHandler) {\n      console.log(\"Datachannel already present for a 2 party conversation\");\n      return;\n    }\n    require([\"DataChannelBroker\"],\n      // successfully received the DataChannelBroker\n      function(dataChannelBroker) {\n        console.log(dataChannelBroker);\n        // assign the dataChannelBroker to the conversation for later reference\n        conversation.dataChannelBroker = dataChannelBroker;\n\n        var dataChannelEvtHandler = new DataChannelEvtHandler(wonderInstance, conversation); // create a new handler for the data channel\n\n        dataChannelBroker.addDataChannelCodec(\n          conversation.myParticipant.identity, // from me\n          conversation.remoteParticipants[0].identity, // to the remote participant\n          msg.misc.demand.in.data, // with the codec of the remote participant || or plain\n          dataChannelEvtHandler // and the handler of the channel\n        )\n        .then(function(codec){\n          // get the codec\n          var codec = dataChannelBroker.getDataChannelCodec(conversation.myParticipant.identity, conversation.remoteParticipants[0].identity, msg.misc.demand.in.data);\n\n          // overwrite the codec with the help of its constructor\n          codec.dataChannel = conversation.myParticipant.peerConnection.createDataChannel(guid()); // create the datachannel and assign it to the codec\n          codec.onMessage = dataChannelEvtHandler.onEvt.bind(dataChannelEvtHandler); // register the handler which will receive the message after the codec is finished decoding the message\n          codec.from = conversation.myParticipant.identity; // tell the codec from whom messages are coming to be sent over the channel\n          codec.to = conversation.remoteParticipants[0].identity; // tell the codec who the receiver is, can be helpful i.e. for chat communication\n\n          // also register the dataChannel in its handler for easier reference\n          dataChannelEvtHandler.dataChannel = codec.dataChannel;\n\n          // override the functions which may be defined in the required codec to standard ones for correct functionality\n          // when the data channel is ready then assign the codec's onDataMessage function to the channel\n          codec.dataChannel.onopen = function(evt) {\n            if (codec.dataChannel.readyState === 'open') codec.dataChannel.onmessage = codec.onDataMessage.bind(codec);\n          }\n\n          // register the data channel handler and bind its class as \"this\" inside the function\n          codec.dataChannel.onclose = dataChannelEvtHandler.onEvt.bind(dataChannelEvtHandler);\n          console.log(\"codec:\",codec);\n          // attach the data channel to the conversation for testing\n          //conversation.dc = codec.dataChannel; // TODO: THIS NEEDS TO BE HANDELED LATER ON!!!!\n\n          // TODO: THIS NEEDS TO BE DONE EVERY TIME A PEERCONNECTION IS CREATED\n          // ondatachannel is a rtcEvent and therefore needs to be handled there\n          conversation.myParticipant.peerConnection.ondatachannel = conversation.rtcEvtHandler.onEvt.bind(conversation.rtcEvtHandler);\n\n          // if a new data channel will be created it is a peer connection event or rtc event respectively\n          conversation.myParticipant.peerConnection.ondatachannel = conversation.rtcEvtHandler.onEvt.bind(conversation.rtcEvtHandler);\n\n          // reject ice handling as long as the sdp isnt set on both ends\n          that.ice = false;\n\n          // set the description of alice\n          conversation.myParticipant.peerConnection.setRemoteDescription(\n            new RTCSessionDescription(msg.misc.sessionDescription),\n            function() {\n              console.log(\"[MsgEvtHandler establishDataChannel] set remote description success\");\n            },\n            errorHandler\n          );\n          console.log(conversation.remoteParticipants);\n          console.log(conversation.myParticipant);\n          // and create my own afterwards (bobs description/answer)\n          conversation.myParticipant.peerConnection.createAnswer(\n            function(answer) {\n              conversation.myParticipant.peerConnection.setLocalDescription(\n                answer,\n                function() {\n                  // and send it to alice when we are ready\n                  var msg = MessageFactory.accepted(\n                    conversation.myParticipant.identity,\n                    conversation.remoteParticipants[0].identity,\n                    conversation.id,\n                    conversation.remoteParticipants[0].demand,\n                    answer\n                  );\n                  conversation.msgStub.sendMessage(msg);\n                },\n                errorHandler\n              );\n            },\n            errorHandler\n          );\n        })\n        .catch(function(err){\n          console.log(err);\n        });\n      }\n    );\n  }\n\n\n\n  /**\n   * @desc This functions establishes a video or audio connection to the remote peer\n   * @param {WONDER} wonderInstance - The instance of WONDER used as a backreference\n   * @param {Conversation} conversation - An reference to the corresponding conversation\n   * @param {Message} msg - The invitation message received\n   */\n  establishRtcConnection(wonderInstance, conversation, msg) {\n    // conversation.remoteParticipants[0].demand.out needs to be updated too\n    navigator.mediaDevices.getUserMedia(msg.misc.demand.in)\n      .then(function(stream) {\n        attachMediaStream(document.getElementById('localVideo'), stream);\n        conversation.myParticipant.peerConnection.addStream(stream);\n\n        // set the descriptiopn of alice\n        conversation.myParticipant.peerConnection.setRemoteDescription(\n          new RTCSessionDescription(msg.misc.sessionDescription),\n          function() {\n            console.log(\"[MsgEvtHandler establishRtcConnection] set remote descriptiopn success\");\n          },\n          errorHandler\n        );\n\n        // and create my own afterwards\n        conversation.myParticipant.peerConnection.createAnswer(\n          function(answer) {\n            conversation.myParticipant.peerConnection.setLocalDescription(\n              answer,\n              function() {\n                // and send it to alice when we are ready\n                console.log(\"conversation.remoteParticipants[0].demand\", conversation.remoteParticipants[0].demand);\n                var msg = MessageFactory.accepted(\n                  conversation.myParticipant.identity,\n                  conversation.remoteParticipants[0].identity,\n                  conversation.id,\n                  conversation.remoteParticipants[0].demand,\n                  answer\n                );\n                conversation.msgStub.sendMessage(msg);\n              },\n              errorHandler\n            );\n          },\n          errorHandler\n        );\n      })\n      .catch(function(error) {\n        return error;\n      });\n  }\n\n\n\n  /**\n   * @desc This function is needed to interrupt the processing of an invitation\n   * and establishes the desired data channel, audio or video connection\n   * after the user has granted his permission to do so.\n   * @param {Message} msg - The invitation message received\n   * @param {Boolean} permission - A Boolean value to represent the users permission to establish a specific connection\n   */\n  answerRequest(msg, permission){\n    var that = this;\n    console.log('[MsgEvtHandler answerRequest] permission granted: ', permission);\n    // choose the right method\n    // TODO: change this to be able to establish a audio/video and a data connection with one invitation\n    if(permission === true){\n      if (msg.misc.demand.in.data || msg.misc.demand.out.data) {\n        that.establishDataChannel(that.wonderInstance, that.conversation, msg);\n      } else {\n        that.establishRtcConnection(that.wonderInstance, that.conversation, msg);\n      }\n    } else {\n      console.log(that.conversation);\n      var msg = MessageFactory.declined(\n        that.conversation.myParticipant.identity,\n        that.conversation.remoteParticipants[0].identity, // use from from value as target for declined message\n        that.conversation.id\n      );\n      that.conversation.msgStub.sendMessage(msg);\n    }\n  }\n\n}\n"
  },
  {
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "MsgEvtHandler",
    "memberof": "libs/modules/MsgEvtHandler.js",
    "longname": "libs/modules/MsgEvtHandler.js~MsgEvtHandler",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/modules/MsgEvtHandler.js",
    "importStyle": null,
    "description": "This class is a handler for messages coming from a messaging server",
    "lineNumber": 15,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "libs/modules/MsgEvtHandler.js~MsgEvtHandler",
    "longname": "libs/modules/MsgEvtHandler.js~MsgEvtHandler#constructor",
    "access": null,
    "description": null,
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "WONDER"
        ],
        "spread": false,
        "optional": false,
        "name": "wonderInstance",
        "description": "The instance of wonder used as a backreference"
      },
      {
        "nullable": null,
        "types": [
          "Conversation"
        ],
        "spread": false,
        "optional": false,
        "name": "conversation",
        "description": "An reference to the related conversation"
      }
    ],
    "generator": false
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "conversation",
    "memberof": "libs/modules/MsgEvtHandler.js~MsgEvtHandler",
    "longname": "libs/modules/MsgEvtHandler.js~MsgEvtHandler#conversation",
    "access": null,
    "description": "An reference to the conversation the event handler is handling incoming messages for",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "Conversation"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "wonderInstance",
    "memberof": "libs/modules/MsgEvtHandler.js~MsgEvtHandler",
    "longname": "libs/modules/MsgEvtHandler.js~MsgEvtHandler#wonderInstance",
    "access": null,
    "description": "Backreference to the wonder instance the message event handler is related to",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "Wonder"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "ice",
    "memberof": "libs/modules/MsgEvtHandler.js~MsgEvtHandler",
    "longname": "libs/modules/MsgEvtHandler.js~MsgEvtHandler#ice",
    "access": null,
    "description": "Flag to be able to tell if ice handling is allowed and the session description exchange of the peer connections is over",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "onMessage",
    "memberof": "libs/modules/MsgEvtHandler.js~MsgEvtHandler",
    "longname": "libs/modules/MsgEvtHandler.js~MsgEvtHandler#onMessage",
    "access": null,
    "description": "This is a function to handle all incoming messages from the messaging server.",
    "examples": [
      "msgStubInstance.onMessage = conversation.msgEvtHandler.onMessage().bind(conversation.msgEvtHandler);"
    ],
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "establishDataChannel",
    "memberof": "libs/modules/MsgEvtHandler.js~MsgEvtHandler",
    "longname": "libs/modules/MsgEvtHandler.js~MsgEvtHandler#establishDataChannel",
    "access": null,
    "description": "This functions establishes a data channel for the invitation receiving side.\nIt is only called from the message event handler itself and shouldn't be used outside of it.",
    "lineNumber": 218,
    "params": [
      {
        "nullable": null,
        "types": [
          "WONDER"
        ],
        "spread": false,
        "optional": false,
        "name": "wonderInstance",
        "description": "The instance of the WONDER class used as a backreference"
      },
      {
        "nullable": null,
        "types": [
          "Conversation"
        ],
        "spread": false,
        "optional": false,
        "name": "conversation",
        "description": "An reference to the corresponding conversation"
      },
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "The invitation message received"
      }
    ],
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "establishRtcConnection",
    "memberof": "libs/modules/MsgEvtHandler.js~MsgEvtHandler",
    "longname": "libs/modules/MsgEvtHandler.js~MsgEvtHandler#establishRtcConnection",
    "access": null,
    "description": "This functions establishes a video or audio connection to the remote peer",
    "lineNumber": 322,
    "params": [
      {
        "nullable": null,
        "types": [
          "WONDER"
        ],
        "spread": false,
        "optional": false,
        "name": "wonderInstance",
        "description": "The instance of WONDER used as a backreference"
      },
      {
        "nullable": null,
        "types": [
          "Conversation"
        ],
        "spread": false,
        "optional": false,
        "name": "conversation",
        "description": "An reference to the corresponding conversation"
      },
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "The invitation message received"
      }
    ],
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "answerRequest",
    "memberof": "libs/modules/MsgEvtHandler.js~MsgEvtHandler",
    "longname": "libs/modules/MsgEvtHandler.js~MsgEvtHandler#answerRequest",
    "access": null,
    "description": "This function is needed to interrupt the processing of an invitation\nand establishes the desired data channel, audio or video connection\nafter the user has granted his permission to do so.",
    "lineNumber": 375,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "The invitation message received"
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "permission",
        "description": "A Boolean value to represent the users permission to establish a specific connection"
      }
    ],
    "generator": false
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/Participant.js",
    "memberof": null,
    "longname": "libs/modules/Participant.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\n/**\n * @class\n * @desc This class represents a participant of a conversation.\n * Identities can be stored in multiple participants but participants\n * with the same identity cannot be in the same conversation.\n */\nclass Participant {\n  /**\n   * @constructor\n   * @param {WONDER} wonderInstance - The instance of the WONDER class used as a backreference\n   * @param {Identity} identity - The identity of the participant\n   * @param {Demand} demand - The resources a participant demands for the communication\n   */\n  constructor(wonderInstance, identity, demand) {\n    /**\n     * @type {WONDER} wonderInstance\n     * @desc Backreference to the WONDER instance\n     */\n    this.wonderInstance = wonderInstance;\n\n    /**\n     * @type {Identity} identity\n     * @desc The identity of the participant\n     */\n    this.identity = identity;\n\n    /**\n     * @type {Demand} demand\n     * @desc The resources a participant demands for the communication\n     */\n    this.demand = new Demand(demand);\n\n    /**\n     * @type {RTCPeerConnection} peerConnection\n     * @desc Used to hold the RTCPeerConnection to this participant\n     */\n    this.peerConnection = null;\n  }\n\n  /**\n   * @desc Returns the RtcPeerConnection of this participant\n   * @return {RTCPeerConnection}\n   */\n  getRtcPeerConnection() {\n    return this.peerConnection;\n  }\n\n  /**\n   * @desc Sets the RtcPeerConnection of this participant\n   * @param {RTCPeerConnection} rtcPeerConnection - The rtcPeerConnection to be set for this participant\n   */\n  setRtcPeerConnection(rtcPeerConnection) {\n    this.peerConnection = rtcPeerConnection;\n    this.peerConnection.onaddstream = this.wonderInstance.conversations[0].rtcEvtHandler.onEvt.bind(this.wonderInstance.conversations[0].rtcEvtHandler);\n    this.peerConnection.onicecandidate = this.wonderInstance.conversations[0].rtcEvtHandler.onEvt.bind(this.wonderInstance.conversations[0].rtcEvtHandler);\n    this.peerConnection.onIceStateChange = this.wonderInstance.conversations[0].rtcEvtHandler.onEvt.bind(this.wonderInstance.conversations[0].rtcEvtHandler);\n  }\n\n  /**\n   * @desc This function updates the demand by adding the new demand to the existing demand\n   * @param {Demand} demand - The demand to be included in the currently stored demand\n   * @TODO rename the function to addDemand\n   */\n  updateDemand(demand) {\n    this.demand = Demand.updateDemandAllow(this.demand, demand);\n  }\n}\n"
  },
  {
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Participant",
    "memberof": "libs/modules/Participant.js",
    "longname": "libs/modules/Participant.js~Participant",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/modules/Participant.js",
    "importStyle": null,
    "description": "This class represents a participant of a conversation.\nIdentities can be stored in multiple participants but participants\nwith the same identity cannot be in the same conversation.",
    "lineNumber": 16,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "libs/modules/Participant.js~Participant",
    "longname": "libs/modules/Participant.js~Participant#constructor",
    "access": null,
    "description": null,
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "WONDER"
        ],
        "spread": false,
        "optional": false,
        "name": "wonderInstance",
        "description": "The instance of the WONDER class used as a backreference"
      },
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "The identity of the participant"
      },
      {
        "nullable": null,
        "types": [
          "Demand"
        ],
        "spread": false,
        "optional": false,
        "name": "demand",
        "description": "The resources a participant demands for the communication"
      }
    ],
    "generator": false
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "wonderInstance",
    "memberof": "libs/modules/Participant.js~Participant",
    "longname": "libs/modules/Participant.js~Participant#wonderInstance",
    "access": null,
    "description": "Backreference to the WONDER instance",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "WONDER"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "identity",
    "memberof": "libs/modules/Participant.js~Participant",
    "longname": "libs/modules/Participant.js~Participant#identity",
    "access": null,
    "description": "The identity of the participant",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "Identity"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "demand",
    "memberof": "libs/modules/Participant.js~Participant",
    "longname": "libs/modules/Participant.js~Participant#demand",
    "access": null,
    "description": "The resources a participant demands for the communication",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "Demand"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "peerConnection",
    "memberof": "libs/modules/Participant.js~Participant",
    "longname": "libs/modules/Participant.js~Participant#peerConnection",
    "access": null,
    "description": "Used to hold the RTCPeerConnection to this participant",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "RTCPeerConnection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getRtcPeerConnection",
    "memberof": "libs/modules/Participant.js~Participant",
    "longname": "libs/modules/Participant.js~Participant#getRtcPeerConnection",
    "access": null,
    "description": "Returns the RtcPeerConnection of this participant",
    "lineNumber": 53,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "RTCPeerConnection"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "setRtcPeerConnection",
    "memberof": "libs/modules/Participant.js~Participant",
    "longname": "libs/modules/Participant.js~Participant#setRtcPeerConnection",
    "access": null,
    "description": "Sets the RtcPeerConnection of this participant",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "RTCPeerConnection"
        ],
        "spread": false,
        "optional": false,
        "name": "rtcPeerConnection",
        "description": "The rtcPeerConnection to be set for this participant"
      }
    ],
    "generator": false
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "peerConnection",
    "memberof": "libs/modules/Participant.js~Participant",
    "longname": "libs/modules/Participant.js~Participant#peerConnection",
    "access": null,
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "updateDemand",
    "memberof": "libs/modules/Participant.js~Participant",
    "longname": "libs/modules/Participant.js~Participant#updateDemand",
    "access": null,
    "description": "This function updates the demand by adding the new demand to the existing demand",
    "lineNumber": 73,
    "unknown": [
      {
        "tagName": "@TODO",
        "tagValue": "rename the function to addDemand"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Demand"
        ],
        "spread": false,
        "optional": false,
        "name": "demand",
        "description": "The demand to be included in the currently stored demand"
      }
    ],
    "generator": false
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "demand",
    "memberof": "libs/modules/Participant.js~Participant",
    "longname": "libs/modules/Participant.js~Participant#demand",
    "access": null,
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/RtcEvtHandler.js",
    "memberof": null,
    "longname": "libs/modules/RtcEvtHandler.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\n/**\n * @class\n * @desc This class is an event handler vor events coming from a peer connection\n */\nclass RtcEvtHandler {\n  /**\n   * @constructor\n   * @param {WONDER} wonderInstance - The instance of the WONDER class used as a backreference\n   * @param {Conversation} conversation - An reference to the corresponding conversation\n   */\n  constructor(wonderInstance, conversation) {\n    /**\n     * @type {WONDER} wonderInstance\n     * @desc Backreference to the wonder instance\n     */\n    this.wonderInstance = wonderInstance;\n\n    /**\n     * @type {Conversation} conversation\n     * @desc An reference to the corresponding conversation\n     */\n    this.conversation = conversation;\n\n    /**\n     * @type {Array} msgbuf\n     * @desc An array for buffering ICE candidate messages before they are sent\n     */\n    this.msgbuf = [];\n  }\n\n\n  /**\n   * @desc This event handler processes events coming from a peer connection.\n   * @param {Object} evt - an event containing the RTC events\n   * @example\n   * participant.peerConnection.ondatachannel = conversation.rtcEvtHandler.onEvt.bind(conversation.rtcEvtHandler);\n   * @TODO The event handler should be in the participant as the peer connection is also there.\n   */\n  onEvt(evt) {\n    var that = this;\n\n    switch (evt.type) {\n      case RtcEvtType.onaddstream:\n        console.log('[RtcEvtHandler onEvt] onaddstream!', evt);\n        break;\n\n      case RtcEvtType.onaddlocalstream:\n        console.log('[RtcEvtHandler onEvt] onaddlocalstream', evt);\n        break;\n\n      case RtcEvtType.onnegotiationneeded:\n        console.log('[RtcEvtHandler onEvt] onnegotiationneeded', evt);\n        that.conversation.myParticipant.peerConnection.createOffer(\n          function(offer) {\n            that.conversation.myParticipant.peerConnection.setLocalDescription(\n              offer,\n              function() {\n                var msg = MessageFactory.updateSdp(\n                  that.conversation.myParticipant.identity,\n                  that.conversation.remoteParticipants[0].identity,\n                  that.conversation.id,\n                  offer\n                );\n                that.conversation.msgStub.sendMessage(msg);\n              },\n              errorHandler\n            );\n          },\n          errorHandler\n        );\n        break;\n\n      case RtcEvtType.onicecandidate:\n        console.log('[RtcEvtHandler onEvt] icecandidate: ', evt);\n        // candidate exists in e.candidate\n        // its triggered when the local machine wants ice\n\n        if (!evt.candidate) return; // when there is no ice candidate present we cannot establish a connection (STUN/TURN needed); or it is the last candidate\n        console.log('[RtcEvtHandler onEvt] conversation: ', this.conversation);\n        console.log(evt);\n\n        var newcandidate = new RTCIceCandidate({ // @TODO remove this and test it\n          sdpMLineIndex: 0,\n          candidate: evt.candidate.candidate,\n          sdpMid: evt.candidate.sdpMid\n        });\n\n        var msg = MessageFactory.updateIceCandidates(\n          that.conversation.myParticipant.identity,\n          that.conversation.remoteParticipants[0].identity,\n          that.conversation.id,\n          evt.candidate\n        ); // create a message with the icecandidates in it\n\n        if (that.conversation.msgEvtHandler.ice) { // send directly when allowed\n          that.conversation.msgStub.sendMessage(msg);\n          // and all others\n          for (var i = that.msgbuf.length - 1; i >= 0; i--) {\n            that.conversation.msgStub.sendMessage(that.msgbuf[i]);\n            that.msgbuf.splice(i, 1);\n          }\n        } else {\n          that.msgbuf.push(msg);\n        }\n        break;\n\n      case RtcEvtType.onsignalingstatechange:\n        console.log('[RtcEvtHandler onEvt] onsignalingstatechange', evt);\n        break;\n\n      case RtcEvtType.onremovestream:\n        console.log('[RtcEvtHandler onEvt] onremovestream', evt);\n\n        break;\n\n      case RtcEvtType.oniceconnectionstatechange:\n        console.log(\"[RtcEvtHandler onEvt] iceConnectionStatechange NOW: \", evt);\n        break;\n\n      case RtcEvtType.ondatachannel:\n        console.log('[RtcEvtHandler onEvt] ondatachannel', evt);\n        if (that.conversation.dataChannelEvtHandler)\n          evt.channel.onmessage = that.conversation.dataChannelEvtHandler.onEvt.bind(that.conversation.dataChannelEvtHandler);\n        else {\n          // @TODO remove static link to the participant, get it more dynamically to support multiparty conversations\n          console.log(\"that.conversation.remoteParticipants[0].demand\",that.conversation.remoteParticipants[0].demand);\n          console.log(that.conversation.remoteParticipants[0].demand.out.data);\n          var codec = that.conversation.dataChannelBroker.getDataChannelCodec(\n            that.conversation.myParticipant.identity,\n            that.conversation.remoteParticipants[0].identity,\n            that.conversation.remoteParticipants[0].demand.out.data\n          );\n          evt.channel.onmessage = codec.onDataMessage.bind(codec);\n          evt.channel.payloadType = that.conversation.remoteParticipants[0].demand.out.data;\n        }\n        break;\n\n      default:\n        console.log('[RtcEvtHandler onEvt] default', evt);\n        break;\n    }\n\n    this.wonderInstance.onRtcEvt(evt);\n  }\n\n}\n"
  },
  {
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "RtcEvtHandler",
    "memberof": "libs/modules/RtcEvtHandler.js",
    "longname": "libs/modules/RtcEvtHandler.js~RtcEvtHandler",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/modules/RtcEvtHandler.js",
    "importStyle": null,
    "description": "This class is an event handler vor events coming from a peer connection",
    "lineNumber": 14,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "libs/modules/RtcEvtHandler.js~RtcEvtHandler",
    "longname": "libs/modules/RtcEvtHandler.js~RtcEvtHandler#constructor",
    "access": null,
    "description": null,
    "lineNumber": 20,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "WONDER"
        ],
        "spread": false,
        "optional": false,
        "name": "wonderInstance",
        "description": "The instance of the WONDER class used as a backreference"
      },
      {
        "nullable": null,
        "types": [
          "Conversation"
        ],
        "spread": false,
        "optional": false,
        "name": "conversation",
        "description": "An reference to the corresponding conversation"
      }
    ],
    "generator": false
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "wonderInstance",
    "memberof": "libs/modules/RtcEvtHandler.js~RtcEvtHandler",
    "longname": "libs/modules/RtcEvtHandler.js~RtcEvtHandler#wonderInstance",
    "access": null,
    "description": "Backreference to the wonder instance",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "WONDER"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "conversation",
    "memberof": "libs/modules/RtcEvtHandler.js~RtcEvtHandler",
    "longname": "libs/modules/RtcEvtHandler.js~RtcEvtHandler#conversation",
    "access": null,
    "description": "An reference to the corresponding conversation",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "Conversation"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "msgbuf",
    "memberof": "libs/modules/RtcEvtHandler.js~RtcEvtHandler",
    "longname": "libs/modules/RtcEvtHandler.js~RtcEvtHandler#msgbuf",
    "access": null,
    "description": "An array for buffering ICE candidate messages before they are sent",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "onEvt",
    "memberof": "libs/modules/RtcEvtHandler.js~RtcEvtHandler",
    "longname": "libs/modules/RtcEvtHandler.js~RtcEvtHandler#onEvt",
    "access": null,
    "description": "This event handler processes events coming from a peer connection.",
    "examples": [
      "participant.peerConnection.ondatachannel = conversation.rtcEvtHandler.onEvt.bind(conversation.rtcEvtHandler);"
    ],
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@TODO",
        "tagValue": "The event handler should be in the participant as the peer connection is also there."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "evt",
        "description": "an event containing the RTC events"
      }
    ],
    "generator": false
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/Types.js",
    "memberof": null,
    "longname": "libs/modules/Types.js",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Steffen Druesedow <Steffen.Druesedow@telekom.de>\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\n/**\n * Enummeration for message types\n * @typedef {String} MessageType\n * @type {Object} MessageType\n *\n */\nvar MessageType = {\n  /** Message to invite a peer to a conversation. */\n  invitation: 'invitation',\n  /** Answer for conversation accepted. */\n  accepted: 'accepted',\n  /** Answer for conversation not accepted. */\n  declined: 'declined',\n  /** Message from a peer to leave a conversation */\n  bye: 'bye',\n  /** Message to add a new {@link Demand} */\n  update: 'update',\n  /** Message to process a new SDP offer or Answer\n  * @TODO use update instead of invitations when being in a conversation already\n  * use updatedSdp when sending the SDP answer and a conversation is already present */\n  updateSdp: 'updateSdp',\n  /** Answer when successfully added the new {@link Demand} */\n  updated: 'updated',\n  /** Message to publish the presence status of the identity */\n  presence: 'presence',\n  /** Message to be used when no predefined type suits the Message\n  * @TODO implement it  */\n  message: 'message',\n  /** Message contains an ICE candidate */\n  connectivityCandidate: 'connectivityCandidate'\n}\n\n/**\n * Enumeration for the peer connection (RTC) event types\n * @typedef {Object} RtcEvtType\n * @type {Object} RtcEvtType\n */\nvar RtcEvtType = {\n  /** Event fired when the remote end adds a audio or video stream to its the peer connection */\n  onaddstream: 'addstream',\n  /** Event occuring when a local audio or video stream is added; this is not a standard peer connection event */\n  onaddlocalstream: 'onaddlocalstream',\n  /** Event fired when the SDP of the peer connection changes and a new SDP negotiation needs to be done */\n  onnegotiationneeded: 'onnegotiationneeded',\n  /** Event occuring each time a new ICE candidate is found and needs to be sent to the remote peer*/\n  onicecandidate: 'icecandidate',\n  /** Event rising when the peer connection signaling state changes */\n  onsignalingstatechange: 'onsignalingstatechange',\n  /** Event triggered when a stream is removed */\n  onremovestream: 'onremovestream',\n  /** Event emerging when the state of the ICE gathering phanse changes **/\n  oniceconnectionstatechange: 'oniceconnectionstatechange',\n  /** Event rising locally when a datachannel is added to the peer connection */\n  ondatachannel: 'datachannel'\n};\n\n/**\n * Enumeration for the DataChannelEvt types\n * @typedef {Object} DataChannelEvtType\n * @type {Object} DataChannelEvtType\n */\nvar DataChannelEvtType = {\n  /** Event seen when a data channel is opened */\n  onopen: 'open',\n  /** Event occuring when the datachannel is closed */\n  onclose: 'onclose',\n  /** Event rising when a message is received through a data channel */\n  onmessage: 'message'\n};\n\n\n/**\n * Enumeration for common payload types\n * @typedef {Object} PayloadType\n * @type {Object} PayloadType\n */\nvar PayloadType = {\n  /** Plain data codec, sends and receives data without altering it */\n  plain: 'plain',\n  /** Data codec for sending files */\n  file: 'file',\n  /** Codec for chat messages */\n  chat: 'chat',\n  /** Codec to send and view images */\n  image: 'image',\n  /** Codec to deal with voice data */\n  voice: 'voice',\n  /** Video codec for non RTC video transportation */\n  video: 'video'\n};\n"
  },
  {
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "MessageType",
    "memberof": "libs/modules/Types.js",
    "longname": "libs/modules/Types.js~MessageType",
    "access": null,
    "description": "Enummeration for message types",
    "lineNumber": 17,
    "type": {
      "types": [
        "String"
      ],
      "optional": false,
      "name": "MessageType"
    }
  },
  {
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "RtcEvtType",
    "memberof": "libs/modules/Types.js",
    "longname": "libs/modules/Types.js~RtcEvtType",
    "access": null,
    "description": "Enumeration for the peer connection (RTC) event types",
    "lineNumber": 48,
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "RtcEvtType"
    }
  },
  {
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "DataChannelEvtType",
    "memberof": "libs/modules/Types.js",
    "longname": "libs/modules/Types.js~DataChannelEvtType",
    "access": null,
    "description": "Enumeration for the DataChannelEvt types",
    "lineNumber": 72,
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "DataChannelEvtType"
    }
  },
  {
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "PayloadType",
    "memberof": "libs/modules/Types.js",
    "longname": "libs/modules/Types.js~PayloadType",
    "access": null,
    "description": "Enumeration for common payload types",
    "lineNumber": 87,
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "PayloadType"
    }
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/callMultiple.js",
    "memberof": null,
    "longname": "libs/modules/callMultiple.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\ndefine(function() {\n  function callMultiple(wonderInstance, recipients, conversation) {\n    return new Promise(function(resolve, reject) {\n\n      console.log('[callMultiple] Multiparty call to', recipients, 'with', demand);\n\n      if (typeof recipients !== 'array') return new Error('false type of recipients');\n\n      // create remote identity and participant\n      wonderInstance.localIdp.getIdentity(recipients)\n        .then(function(identities) {\n          conversation.owner = conversation.myParticipant; // set me to the owner as i started the conversation\n\n          for (var i = 0; i < identities.length; i++) {\n            var participant = new Participant(wonderInstance, identities[i]);\n            conversation.remoteParticipants.push(participant); // set the conversation's participants\n          }\n          resolve(conversation);\n        })\n        .catch(function(error) {\n          reject(new Error('[callMultiple] error: ', error));\n        });\n    });\n  }\n\n  return callMultiple;\n});\n"
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/callSingle.js",
    "memberof": null,
    "longname": "libs/modules/callSingle.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\ndefine(function() {\n\n  function callSingle(wonderInstance, recipient, conversation, demand) {\n    return new Promise(function(resolve, reject) {\n      console.log(conversation);\n      // error handling\n      if (typeof recipient !== 'string') return new Error('false type of recipient');\n\n      // create remote identity and participant\n      wonderInstance.localIdp.getIdentity(recipient)\n      .then(function(identity) {\n        var participant = new Participant(wonderInstance, identity);\n        conversation.remoteParticipants.push(participant); // set the conversation's participants\n        conversation.msgSrv = identity.msgSrv; // use the recipient's messaging server\n        if (conversation.msgSrv == conversation.myParticipant.identity.msgSrv) {\n          // remote identity exists on the same server as mine\n          conversation.msgStub = conversation.myParticipant.identity.msgStub;\n          console.log(\"[callSingle] already connected to the remote participants msgServer\");\n        } else {\n          // if its another server create a new connection\n          conversation.msgStub = new identity.msgStub.constructor; // use the remote identity's msgStub\n          // connect the stub of the conversation to the remote server\n          conversation.msgStub.connect(\n            wonderInstance.myIdentity.rtcIdentity, // use my rtcIdentity to connect to the remote server\n            participant.identity.credentials, // use the remote participants credentials for that\n            participant.identity.msgSrv, // the destination messaging server\n            function() { // successfully connected\n              console.log('[callSingle] connected to REMOTE PARTICIPANTs msgServer');\n              resolve(conversation.id);\n              return conversation.id;\n            }\n          );\n        }\n\n        // set the conversation's messaging event handler for every message coming throuh the messaing server\n        conversation.msgStub.onMessage = conversation.msgEvtHandler.onMessage.bind(conversation.msgEvtHandler);\n      })\n      .catch(function(error) {\n        reject(error);\n      }) // Promise of getIdentity is over here\n\n      // take the promise from getIdentity\n      .then(function(conversationId) {\n        // needs to be here when data audio and video are requested all together\n        Demand.updateDemandDisallow(demand, {data:true})\n\n        navigator.mediaDevices.getUserMedia(demand.out) // local participant demands video or audio to send\n        .then(function(stream) {\n          var evt = {\n            type: RtcEvtType.onaddlocalstream,\n            stream: stream\n          }\n          conversation.rtcEvtHandler.onEvt(evt);\n          conversation.myParticipant.peerConnection.addStream(stream); // add the stream to the peer connection to send it later on\n          conversation.myParticipant.peerConnection.createOffer( // create the sdp offer now for both participants\n            function(offer) {\n              console.log(\"[callSingle] offer from alice: \", offer.sdp);\n              conversation.myParticipant.peerConnection.setLocalDescription( // now set the peer connection description\n                offer, // with the local offer\n                function() {\n                  console.log(\"[callSingle] local description success\");\n                  var msg = MessageFactory.invitation( // create the message for the remote participant\n                    conversation.myParticipant.identity,\n                    conversation.remoteParticipants[0].identity,\n                    conversation.id,\n                    conversation.myParticipant.demand, // also send the demand so bob knows what to expect from alice\n                    offer // include the sdp offer for bob\n                  );\n                  conversation.msgStub.sendMessage(msg); // and send the mesage\n                },\n                function(error) {\n                  console.log(error);\n                  reject(error);\n                }\n              );\n            },\n            function(error) {\n              console.log(error);\n              reject(error);\n            }, {\n              offerToReceiveAudio: 1,\n              offerToReceiveVideo: 1\n            }\n          ); // create offer ends here\n          resolve(conversation.id);\n        })\n        .catch(function(error) {\n          reject(error);\n          return error;\n        }); // getUserMedia promise ends here\n\n        resolve(conversation.id); // return the conversationId if everything went right\n      })\n      .catch(function(error) {\n        reject(new Error('[callSingle] error:', error));\n      }); // promise returned by getIdentity ends here\n\n    }); // callSingle promise will be returned here\n  }\n\n  return callSingle; // necessary due to requireJS\n});\n"
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/codecPlain.js",
    "memberof": null,
    "longname": "libs/modules/codecPlain.js",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n * @returns {Codec}\n */\n\n'use strict';\n\ndefine(function(require, exports, module) {\n  /**\n   * @class\n   * @desc A Codec for plain text\n   */\n  class Codec {\n    /**\n     * @constructor\n     */\n    constructor(dataChannel, onMessage) {\n      /**\n       * @type {RTCDataChannel} dataChannel\n       * @desc an datachannel where the codec should be established\n       */\n      this.dataChannel = dataChannel;\n\n      /**\n       * @type {function} onMessage\n       * @desc The linked onmessage function for processing data result\n       */\n      this.onMessage = onMessage;\n    }\n\n    /**\n     * send function\n     * @param {Object} input - The input data for this codec\n     * @param {RTCDataChannel} dataChannel - A RtcDataChannel over which the data should be sended\n     */\n    send(input, dataChannel) {\n      console.log('[Codec Plain] send:', input, dataChannel);\n      if (dataChannel) dataChannel.send(input); // when used as a geneal codec for many data channels\n      else this.dataChannel.send(JSON.stringify(input)); // when instanciated only for a particular channel\n    }\n\n    /**\n     * onDataMessage function\n     * @param {String} dataMsg\n     * @desc This is the function which will be registered on the DataChannel.onmessage-function\n     * @desc This function needs to modify the incoming message and send it to this.onMessage afterwards\n     */\n    onDataMessage(dataMsg) {\n      console.log('[Codec Plain] onData:', dataMsg);\n      this.onMessage(dataMsg);\n    }\n\n  }\n\n  /**\n   * @return {Codec} an instance of the Codec\n   */\n  return new Codec();\n});\n"
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/dataChannel.js",
    "memberof": null,
    "longname": "libs/modules/dataChannel.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n'use strict';\n\ndefine(function() {\n\n  function dataChannel(wonderInstance, recipient, conversation, payloadType) {\n    return new Promise(function(resolve, reject) {\n\n      console.log('[dataChannel] establishing data channel to', recipient, 'with', conversation.myParticipant.demand, 'payloadType=',payloadType);\n\n      if (typeof recipient !== 'string') return new Error('false type of recipient');\n\n      // create remote identity and participant\n      wonderInstance.localIdp.getIdentity(recipient)\n      .then(function(identity) {\n\n        // check if the remote participant exists\n        var participant = conversation.getRemoteParticipant(identity);\n\n        // if a Data-Channel to that participant/identity wasn't created already\n        if (!participant) {\n          participant = new Participant(wonderInstance, identity, {in:{data: payloadType}, out:{data:payloadType}}); // create a new participant\n          conversation.addRemoteParticipant(participant); // set the conversation's participants\n          conversation.msgSrv = identity.msgSrv; // use the recipient's messaging server\n        }\n\n        // check if we are already on the same messaging server as the remote participant\n        if (conversation.msgSrv == conversation.myParticipant.identity.msgSrv) {\n          // remote identity exists on the same server as mine\n          conversation.msgStub = conversation.myParticipant.identity.msgStub; // so use my connection\n          console.log(\"[dataChannel] already connected to the remote participants msgServer\");\n          resolve();\n        } else {\n          // if it is another server then create a new connection\n          conversation.msgStub = new identity.msgStub.constructor; // use the remote identity's msgStub\n\n          // connect the stub of the conversation to the remote server\n          conversation.msgStub.connect(\n            wonderInstance.myIdentity.rtcIdentity, // use my rtcIdentity to connect to the remote server\n            participant.identity.credentials, // use the remote participants credentials for that\n            participant.identity.msgSrv, // the destination messaging server\n            function() { // successfully connected\n              console.log('[dataChannel] connected to remote participants msgServer');\n              resolve();\n            }\n          );\n        }\n        return identity; // pass identity to next .then-function\n      })\n      .catch(function(error) {\n        reject(error);\n      }) // promise of getIdentity is over here\n\n      // take the promise from getIdentity\n      .then(function(identity) {\n        require([\"DataChannelBroker\"],\n          // successfully received the DataChannelBroker\n          function(dataChannelBroker) {\n            // set the conversation's messaging event handler for every message coming through the messaing server\n            conversation.msgStub.onMessage = conversation.msgEvtHandler.onMessage.bind(conversation.msgEvtHandler);\n\n            // assign the dataChannelBroker to the conversation for later reference\n            conversation.dataChannelBroker = dataChannelBroker;\n\n            // create a new data channel handler for every data channel\n            var dataChannelEvtHandler = new DataChannelEvtHandler(wonderInstance, conversation);\n\n            // download a new codec; add it to the broker; add the event handler to the codec\n            dataChannelBroker.addDataChannelCodec(\n              conversation.myParticipant.identity, // from me\n              identity, // to the remote participant\n              payloadType, // with the codec of the remote participant || or plain\n              dataChannelEvtHandler // and the handler of the channel\n            )\n            .then(function(codec){\n              // get the codec\n              var codec = dataChannelBroker.getDataChannelCodec(conversation.myParticipant.identity, identity, payloadType);\n\n              // overwrite the codec with the help of its constructor\n              codec.dataChannel = conversation.myParticipant.peerConnection.createDataChannel(guid()); // create the datachannel and assign it to the codec\n              codec.dataChannel.payloadType = payloadType;\n              codec.onMessage = dataChannelEvtHandler.onEvt.bind(dataChannelEvtHandler); // register the handler which will receive the message after the codec is finished decoding the message\n              codec.from = conversation.myParticipant.identity; // tell the codec from whom messages are coming to be sent over the channel\n              codec.to = identity; // tell the codec who the receiver is, can be helpful i.e. for chat communication\n\n              // also register the dataChannel in its handler for easier reference\n              dataChannelEvtHandler.dataChannel = codec.dataChannel;\n\n              // override the functions which may be defined in the required codec to standard ones for correct functionality\n              // when the data channel is ready then assign the codec's onDataMessage function to the channel\n              codec.dataChannel.onopen = function(evt) {\n                if (codec.dataChannel.readyState === 'open') codec.dataChannel.onmessage = codec.onDataMessage.bind(codec);\n              }\n\n              // register the data channel handler and bind its class as \"this\" inside the function\n              codec.dataChannel.onclose = dataChannelEvtHandler.onEvt.bind(dataChannelEvtHandler);\n              // attach the data channel to the conversation for testing\n              //conversation.dc = codec.dataChannel; // TODO: THIS NEEDS TO BE HANDELED LATER ON!!!!\n\n              // TODO: THIS NEEDS TO BE DONE EVERY TIME A PEERCONNECTION IS CREATED\n              // ondatachannel is a rtcEvent and therefore needs to be handled there\n              conversation.myParticipant.peerConnection.ondatachannel = conversation.rtcEvtHandler.onEvt.bind(conversation.rtcEvtHandler);\n\n              conversation.myParticipant.peerConnection.createOffer( // create the sdp offer now for both participants\n                function(offer) {\n                  console.log(\"[dataChannel createOffer] offer from alice: \", offer.sdp);\n                  conversation.myParticipant.peerConnection.setLocalDescription( // now set the peer connection description\n                    offer, // with the local offer\n                    function() {\n                      console.log(\"[dataChannel createOffer] local description success\");\n                    },\n                    function(error) {\n                      console.log(error);\n                      reject(error);\n                    }\n                  );\n\n                  var msg = MessageFactory.invitation( // create the message for the remote participant\n                    conversation.myParticipant.identity,\n                    conversation.remoteParticipants[0].identity,\n                    conversation.id,\n                    conversation.remoteParticipants[0].demand, // also send the demand so bob knows what to expect from alice\n                    offer // include the sdp offer for bob\n                  );\n                  conversation.msgStub.sendMessage(msg); // and send the message\n                },\n                function(error) {\n                  console.log(error);\n                  reject(error);\n                }\n              ); // create offer ends here\n\n              resolve(conversation.id); // return the conversationId if everything went right\n            },\n            // DataChannelBroker download failed\n            function(error) {\n              reject(Error('[dataChannel] dataChannelBroker requiring failed: ', error));\n            }\n          );\n        }) // addDataChannelCodec promise ends here\n        .catch(function(error){\n          console.error(error);\n        });\n      })\n      .catch(function(error) {\n        reject(new Error('dataChannel: ', error));\n      }); // promise returned by getIdentity ends here\n\n\n    });\n  }\n\n  return dataChannel;\n});\n"
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/helpfunctions.js",
    "memberof": null,
    "longname": "libs/modules/helpfunctions.js",
    "access": null,
    "description": null,
    "lineNumber": 17,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Paulo Chainho <paulo-g-chainho@ptinovacao.pt>\n * @author Steffen Druesedow <Steffen.Druesedow@telekom.de>\n * @author Miguel Seijo Simo <Miguel.Seijo@telekom.de>\n * @author Vasco Amaral <vasco-m-amaral@ptinovacao.pt>\n * @author Kay Haensge <Kay.Haensge@telekom.de>\n * @author Luis Oliveira <luis-f-oliveira@ptinovacao.pt>\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n */\n\n/**\n * @ignore\n */\nfunction uuid4() {\n  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n}\n\n\n\n/**\n * @desc The function generates a unique id\n * @typedef {string} GUID\n * @example 12345678-9ABC-DEF0-1234-56789ABCDEF0\n */\nfunction guid() {\n  return uuid4() + uuid4() + '-' + uuid4() + '-' + uuid4() + '-' + uuid4() + '-' + uuid4() + uuid4() + uuid4();\n}\n\n\n\n/**\n * @desc This function logs errors\n * @return {function}\n */\nvar errorHandler = function(error) {\n  console.log(error);\n}\n\n\n\n/**\n * @desc This is a polyfill for Array.find which iterates through an array and returns the desired value.\n * It expects a function as a parameter which must return false when the current value isn't the desired value\n * and true if the value is the searched one. It only returns the first value which is a match and ignores the following.\n * @return {Object}\n * @example\n * var a = {a:true , b:true };\n * var b = {a:true , b:false};\n * var c = {a:false, b:true };\n * var d = {a:false, b:false};\n * var array = [a,b,c,d];\n * var value = array.find( function(obj){\n *   return obj.a == false;\n * });\n * console.log(value); // returns the object c: {a: false, b: true}\n */\nif (!Array.prototype.find) {\n  Array.prototype.find = function(predicate) {\n    if (this === null) {\n      throw new TypeError('Array.prototype.find called on null or undefined');\n    }\n    if (typeof predicate !== 'function') {\n      throw new TypeError('predicate must be a function');\n    }\n    var list = Object(this);\n    var length = list.length >>> 0;\n    var thisArg = arguments[1];\n    var value;\n\n    for (var i = 0; i < length; i++) {\n      value = list[i];\n      if (predicate.call(thisArg, value, i, list)) {\n        return value;\n      }\n    }\n    return undefined;\n  };\n}\n"
  },
  {
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "uuid4",
    "memberof": "libs/modules/helpfunctions.js",
    "longname": "libs/modules/helpfunctions.js~uuid4",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/modules/helpfunctions.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "GUID",
    "memberof": "libs/modules/helpfunctions.js",
    "longname": "libs/modules/helpfunctions.js~GUID",
    "access": null,
    "description": "The function generates a unique id",
    "examples": [
      "12345678-9ABC-DEF0-1234-56789ABCDEF0"
    ],
    "lineNumber": 28,
    "type": {
      "types": [
        "string"
      ],
      "optional": false,
      "name": "GUID"
    }
  },
  {
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "errorHandler",
    "memberof": "libs/modules/helpfunctions.js",
    "longname": "libs/modules/helpfunctions.js~errorHandler",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/modules/helpfunctions.js",
    "importStyle": null,
    "description": "This function logs errors",
    "lineNumber": 38,
    "params": [
      {
        "name": "error",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/modules/webfinger.js",
    "memberof": null,
    "longname": "libs/modules/webfinger.js",
    "access": null,
    "description": null,
    "lineNumber": 19,
    "content": "/*!\n * webfinger.js\n *   version 2.2.0\n *   http://github.com/silverbucket/webfinger.js\n *\n * Developed and Maintained by:\n *   Nick Jennings <nick@silverbucket.net> 2012 - 2014\n *\n * webfinger.js is released under the AGPL (see LICENSE).\n *\n * You don't have to do anything special to choose one license or the other and you don't\n * have to notify anyone which license you are using.\n * Please see the corresponding license file for details of these licenses.\n * You are free to use, modify and distribute this software, but all copyright\n * information must remain.\n *\n */\n\nif (typeof XMLHttpRequest === 'undefined') {\n  XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;\n}\n\n(function (undefined) {\n\n  // URI to property name map\n  var LINK_URI_MAPS = {\n    'http://webfist.org/spec/rel': 'webfist',\n    'http://webfinger.net/rel/avatar': 'avatar',\n    'remotestorage': 'remotestorage',\n    'remoteStorage': 'remotestorage',\n    'http://www.packetizer.com/rel/share': 'share',\n    'http://webfinger.net/rel/profile-page': 'profile',\n    'me': 'profile',\n    'vcard': 'vcard',\n    'blog': 'blog',\n    'http://packetizer.com/rel/blog': 'blog',\n    'http://schemas.google.com/g/2010#updates-from': 'updates',\n    'https://camlistore.org/rel/server': 'camilstore'\n  };\n\n  var LINK_PROPERTIES = {\n    'avatar': [],\n    'remotestorage': [],\n    'blog': [],\n    'vcard': [],\n    'updates': [],\n    'share': [],\n    'profile': [],\n    'webfist': [],\n    'camlistore': []\n  };\n\n  // list of endpoints to try, fallback from beginning to end.\n  var URIS = ['webfinger', 'host-meta', 'host-meta.json'];\n\n  function _err(obj) {\n    obj.toString = function () {\n      return this.message;\n    };\n    return obj;\n  }\n\n  /**\n   * Function: WebFinger\n   *\n   * WebFinger constructor\n   *\n   * Returns:\n   *\n   *   return WebFinger object\n   */\n  function WebFinger(config) {\n    if (typeof config !== 'object') {\n      config = {};\n    }\n\n    this.config = {\n      tls_only:         (typeof config.tls_only !== 'undefined') ? config.tls_only : true,\n      webfist_fallback: (typeof config.webfist_fallback !== 'undefined') ? config.webfist_fallback : false,\n      uri_fallback:     (typeof config.uri_fallback !== 'undefined') ? config.uri_fallback : false,\n      request_timeout:  (typeof config.request_timeout !== 'undefined') ? config.request_timeout : 10000\n    };\n  }\n\n  // make an http request and look for JRD response, fails if request fails\n  // or response not json.\n  WebFinger.prototype._fetchJRD = function (url, cb) {\n    var self = this;\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = function () {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          if (self._isValidJSON(xhr.responseText)) {\n            cb(null, xhr.responseText);\n          } else {\n            cb(_err({\n              message: 'invalid json',\n              url: url,\n              status: xhr.status\n            }));\n          }\n        } else if (xhr.status === 404) {\n          cb(_err({\n            message: 'endpoint unreachable',\n            url: url,\n            status: xhr.status\n          }));\n        } else {\n          cb(_err({\n            message: 'error during request',\n            url: url,\n            status: xhr.status\n          }));\n        }\n      }\n    };\n\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Accept', 'application/jrd+json, application/json');\n    xhr.send();\n  };\n\n  WebFinger.prototype._isValidJSON = function (str) {\n    try {\n      JSON.parse(str);\n    } catch (e) {\n      return false;\n    }\n    return true;\n  };\n\n  WebFinger.prototype._isLocalhost = function (host) {\n    var local = /^localhost(\\.localdomain)?(\\:[0-9]+)?$/;\n    return local.test(host);\n  };\n\n  // processes JRD object as if it's a webfinger response object\n  // looks for known properties and adds them to profile datat struct.\n  WebFinger.prototype._processJRD = function (JRD, cb) {\n    var self = this;\n    var parsedJRD = JSON.parse(JRD);\n    if ((typeof parsedJRD !== 'object') ||\n        (typeof parsedJRD.links !== 'object')) {\n      if (typeof parsedJRD.error !== 'undefined') {\n        cb(_err({ message: parsedJRD.error }));\n      } else {\n        cb(_err({ message: 'unknown response from server' }));\n      }\n      return false;\n    }\n\n    var links = parsedJRD.links;\n    var result = {  // webfinger JRD - object, json, and our own indexing\n      object: parsedJRD,\n      json: JRD,\n      idx: {}\n    };\n\n    result.idx.properties = {\n      'name': undefined\n    };\n    result.idx.links = JSON.parse(JSON.stringify(LINK_PROPERTIES));\n\n    // process links\n    links.map(function (link, i) {\n      if (LINK_URI_MAPS.hasOwnProperty(link.rel)) {\n        if (result.idx.links[LINK_URI_MAPS[link.rel]]) {\n          var entry = {};\n          Object.keys(link).map(function (item, n) {\n            entry[item] = link[item];\n          });\n          result.idx.links[LINK_URI_MAPS[link.rel]].push(entry);\n        }\n      }\n    });\n\n    // process properties\n    var props = JSON.parse(JRD).properties;\n    for (var key in props) {\n      if (props.hasOwnProperty(key)) {\n        if (key === 'http://packetizer.com/ns/name') {\n          result.idx.properties.name = props[key];\n        }\n      }\n    }\n    cb(null, result);\n  };\n\n  WebFinger.prototype.lookup = function (address, cb) {\n    if (typeof address !== 'string') {\n      throw new Error('first parameter must be a user address');\n    } else if (typeof cb !== 'function') {\n      throw new Error('second parameter must be a callback');\n    }\n\n    var self = this;\n    var parts = address.replace(/ /g,'').split('@');\n    var host = parts[1];    // host name for this useraddress\n    var uri_index = 0;      // track which URIS we've tried already\n    var protocol = 'https'; // we use https by default\n\n    if (parts.length !== 2) {\n      cb(_err({ message: 'invalid user address ' + address + ' ( expected format: user@host.com )' }));\n      return false;\n    } else if (self._isLocalhost(host)) {\n      protocol = 'http';\n    }\n\n    function _buildURL() {\n      return protocol + '://' + host + '/.well-known/' +\n             URIS[uri_index] + '?resource=acct:' + address;\n    }\n\n    // control flow for failures, what to do in various cases, etc.\n    function _fallbackChecks(err) {\n      if ((self.config.uri_fallback) && (host !== 'webfist.org') && (uri_index !== URIS.length - 1)) { // we have uris left to try\n        uri_index = uri_index + 1;\n        _call();\n      } else if ((!self.config.tls_only) && (protocol === 'https')) { // try normal http\n        uri_index = 0;\n        protocol = 'http';\n        _call();\n      } else if ((self.config.webfist_fallback) && (host !== 'webfist.org')) { // webfist attempt\n        uri_index = 0;\n        protocol = 'http';\n        host = 'webfist.org';\n        // webfist will\n        // 1. make a query to the webfist server for the users account\n        // 2. from the response, get a link to the actual webfinger json data\n        //    (stored somewhere in control of the user)\n        // 3. make a request to that url and get the json\n        // 4. process it like a normal webfinger response\n        self._fetchJRD(_buildURL(), function (err, data) { // get link to users JRD\n          if (err) {\n            cb(err);\n            return false;\n          }\n          self._processJRD(data, function (err, result) {\n            if ((typeof result.idx.links.webfist === 'object') &&\n                (typeof result.idx.links.webfist[0].href === 'string')) {\n              self._fetchJRD(result.idx.links.webfist[0].href, function (err, JRD) {\n                if (err) {\n                  cb(err);\n                } else {\n                  self._processJRD(JRD, cb);\n                }\n              });\n            }\n          });\n        });\n      } else {\n        cb(err);\n        return false;\n      }\n    }\n\n    function _call() {\n      // make request\n      self._fetchJRD(_buildURL(), function (err, JRD) {\n        if (err) {\n          _fallbackChecks(err);\n        } else {\n          self._processJRD(JRD, cb);\n        }\n      });\n    }\n\n    setTimeout(_call, 0);\n  };\n\n  WebFinger.prototype.lookupLink = function (address, rel, cb) {\n    if (LINK_PROPERTIES.hasOwnProperty(rel)) {\n      this.lookup(address, function (err, p) {\n        var links  = p.idx.links[rel];\n        if (err) {\n          cb (err);\n        } else if (links.length === 0) {\n          cb ('no links found with rel=\"' + rel + '\"');\n        } else {\n          cb (null, links[0]);\n        }\n      });\n    } else {\n      cb ('unsupported rel ' + rel);\n    }\n  };\n\n  if (typeof window === 'object') {\n    window.WebFinger = WebFinger;\n  } else if (typeof (define) === 'function' && define.amd) {\n    define([], function () { return WebFinger; });\n  } else {\n    try {\n      module.exports = WebFinger;\n    } catch (e) {}\n  }\n})();\n"
  },
  {
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "libs/wonder.js",
    "memberof": null,
    "longname": "libs/wonder.js",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "content": "/**\n * @desc WebRTC framework to facilitate the development of Applications which seamlessly interoperate with each other\n * This framework is based on @see https://github.com/hypercomm/wonder\n * @author Danny Koppenhagen <mail@d-koppenhagen.de>\n * @author Johannes Hamfler <jh@z7k.de>\n * @version 0.1.0\n */\n\n'use strict';\n/*\n(function(undefined) {\n  if (typeof(define) === 'function' && define.amd) {\n    define([\n      'adapter',\n      'Conversation',\n      'Demand',\n      'helpfunctions',\n      'Identity',\n      'Idp',\n      'Message',\n      'MessageFactory',\n      'MsgEvtHandler',\n      'Participant',\n      'RtcEvtHandler',\n      'Types',\n      'DataChannelEvtHandler'\n    ], function() {\n    */\n      /**\n       * @class\n       * @desc The WONDER class is used for developers for interacting with all other WONDER related classes.\n       * The class uses simple interfaces for login, call, etc.\n       * All operations will start with wonder.<function-name> and will return a promise and a callback (either successCallback or errorCallback).\n       * @example wonder.<funcion>(<params>).then(function(successCallbackData){<code>}, function(errorCallbackData){<code>})\n       * @return {WONDER}\n       * @alias module:wonder\n       */\n      class WONDER {\n        /**\n         * @constructor\n         * @example\n         * // needs to be included in a html file\n         * <script src=\"require.min.js\"></script>\n         * <script type=\"text/javascript\">\n         *   // require.config is optional and only necessary if the wonder framework is not in the same directory like require.js\n         *   // for additional information visit: http://requirejs.org/docs/api.html#config\n         *   require.config({\n         *     paths: { 'wonder': 'js/wonder' } // includes js/wonder.js\n         *   });\n         *   require(['wonder'], function(wonderInstance){\n         *     wonderInstance.login(\"alice@example.org\");\n         *     // do other things here like calling bob\n         *   });\n         * </script>\n         */\n        constructor() {\n          /**\n           * @type {Object} config\n           * @desc An object with a configuration\n           * The standard values are set by default when the user doesn't want to do\n           * it on his own.\n           * @example\n           * {\n           *  idp: 'webfinger',\n           *  // alternatively an own idp with:\n           *  // idp:{ url:  \"http://example.com\",\n           *  //       port: '2222',\n           *  //       path: '/u?jsonp=define&identity'   }\n           *  autoAccept: false, // accept invitations automatically\n           *  ice: [\n           *     {urls:'stun:stun.example.com'}, // stunserver\n           *     { // turnserver\n           *       urls: 'turn:turn.example.org:11111?transport=tcp',\n           *       credential: 'credeantialAccessString',\n           *       username: 'usernameToAccess'\n           *     }\n           *   ]\n           * }\n           */\n          this.config = {\n            // automatic accept all invitations\n            autoAccept: true,\n\n            // location of the identity provider\n            idp: 'webfinger', // default value (search for identities with webfinger)\n\n            // default ice servers\n            ice: [{\n              urls: 'stun:stun.voiparound.com'\n            }, {\n              urls: 'stun:stun.voipbuster.com'\n            }, {\n              urls: 'stun:stun.voipstunt.com'\n            }, {\n              urls: 'stun:stun.voxgratia.org'\n            }, {\n              urls: 'stun:stun.ekiga.net'\n            }, {\n              urls: 'stun:stun.schlund.de'\n            }, {\n              urls: 'stun:stun.iptel.org'\n            }, {\n              urls: 'stun:stun.l.google.com:19302'\n            }, {\n              urls: 'stun:stun1.l.google.com:19302'\n            }, {\n              urls: 'stun:stun.ideasip.com'\n            }, {\n              urls: 'stun:stun4.l.google.com:19302'\n            }, {\n              urls: 'stun:stun2.l.google.com:19302'\n            }, {\n              urls: 'stun:stun3.l.google.com:19302'\n            }, {\n              urls: 'turn:192.158.29.39:3478?transport=tcp',\n              credential: 'JZEOEt2V3Qb0y27GRntt2u2PAYA=',\n              username: '28224511:1379330808'\n            }, {\n              urls: 'turn:192.158.29.39:3478?transport=udp',\n              credential: 'JZEOEt2V3Qb0y27GRntt2u2PAYA=',\n              username: '28224511:1379330808'\n            }, {\n              urls: 'turn:numb.viagenie.ca',\n              credential: 'muazkh',\n              username: 'webrtc@live.com'\n            }]\n          };\n\n          /**\n           * @type {Array<Conversation>} conversations\n           * @desc The conversations used in this WONDER instance\n           */\n          this.conversations = [];\n\n          /**\n           * @type {Identity} myIdentity\n           * @desc The identity of the local user\n           */\n          this.myIdentity = null;\n\n          /**\n           * @type {Idp} localIdp\n           * @desc The local identity provider residing in the local WONDER instance\n           * used to interact with the remote identity provider. It is there to be\n           * able to abstact the remote identity provider and define a common\n           * interface to WONDER functions.\n           * It resolves identities via WebFinger or JSONP.\n           */\n          this.localIdp = null;\n\n          /**\n           * @type {function(msg: Message, conversationId: GUID)} onMessage\n           * @desc The variable on which the framework user can register his own message event handler.\n           * It is called after the WONDER framework is finished processing each message.\n           * Is meant to deliver events which originate from the messaging server.\n           * @example wonder.onMessage = function(msg, conversationId) { ... }\n           */\n          this.onMessage = new Function();\n\n\n          /**\n           * @type {function(msg: Object, conversationId: GUID)} onRtcEvt\n           * @desc The variable on which the framework user can register an event handler for wonder rtc (peer connection) events.\n           * It is called after the WONDER framework is finished processing each\n           * Is meant to deliver events which originate from the peer connection to another user.\n           * @example wonder.onRtcEvt = function(msg, conversationId) { ... }\n           */\n          this.onRtcEvt = new Function();\n\n          /**\n           * @type {function(msg: Object, conversationId: GUID)} onDataChannelEvt\n           * @desc The variable on which the framework user can register an event handler for wonder data channel events.\n           * It is called after the WONDER framework is finished processing each\n           * Is meant to deliver events which originate from the peer connection's datachannels to another user.\n           * @example wonder.onDataChannelEvt = function(msg, conversationId){ ... }\n           */\n          this.onDataChannelEvt = new Function();\n        }\n\n        /**\n         * @desc The function starts a user login at the identity provider.\n         * @param {String} myRtcIdentity - The username (login name) of the local identity\n         * @param {Object} credentials - An object with additional login credentials (password, sip-credentials, etc.); may be undefined or null or an empty string\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         * @return {Promise<Identity>|function(identity: Identity)}\n         * @example\n         * wonder.login(\"alice@example.net\", \"\")\n         * .then(function(identity){\n         *   // use the identity to extract the user's aliases, avatar or other information\n         * });\n         */\n        login(myRtcIdentity, credentials, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          console.log('[WONDER login] login with:', myRtcIdentity);\n\n          return new Promise(function(resolve, reject) {\n\n            // errorCallback handling\n            if (!myRtcIdentity) {\n              errMsg = new Error('[WONDER login] errorCallback: no login name received');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n            if (credentials === undefined || credentials === null) credentials = '';\n            if (!that.localIdp) {\n              if (typeof that.config.idp === 'string' && that.config.idp === 'webfinger') {\n                console.log('[WONDER login] looking for identities using Webfinger...');\n                that.localIdp = new Idp('webfinger', myRtcIdentity);\n              } else if (typeof that.config.idp === 'object') {\n                that.localIdp = new Idp(that.config.idp.url + ':' + that.config.idp.port + that.config.idp.path, myRtcIdentity);\n              } else {\n                errMsg = new Error('[WONDER login] errorCallback: Wrong idp format in configuration');\n                reject(errMsg);\n                if (errorCallback) errorCallback(errMsg);\n                return;\n              }\n            }\n\n            that.localIdp.getIdentity(myRtcIdentity, credentials)\n              .then(function(identity) {\n                console.log('[WONDER login]: got identity: ', identity);\n                that.myIdentity = identity;\n                var invitationHandler = new MsgEvtHandler(that); // we need to receive invitations\n                // as we are registering the handler on the messaging stub we need to replace the reference to\n                // this == msgStub with this == invitationHandler\n                identity.msgStub.onMessage = invitationHandler.onMessage.bind(invitationHandler);\n                // SD 06.10.15: add credentials to the identity\n                identity.credentials = credentials;\n\n                identity.msgStub.connect( // and connect to the own mesaging server\n                  identity.rtcIdentity,\n                  identity.credentials,\n                  identity.msgSrv,\n                  function() { // successCallback connecting\n                    console.log('[WONDER login] connected to msgServer of identity: ', identity);\n                    resolve(identity);\n                    if (successCallback) successCallback(identity);\n                  }\n                );\n\n              })\n              .catch(function(err) { // possibly a network errorCallback\n                errMsg = new Error('[WONDER login] ', err);\n                reject(errMsg);\n                if (errorCallback) errorCallback(errMsg);\n                return;\n              });\n          });\n        }\n\n\n\n        /**\n         * @desc A function to start a new call.\n         *\n         * @param {Array<String>|String} recipients - The rtcIdentity as a string for the reciepients (e.g. alice@example.com)\n         * @param {String|Array<String>|Object} demand - An object with the own media constraints for the offer\n         * @param {GUID} [conversationId] - To assign a call to an exiting conversation\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         * @return {Promise<GUID>|function(conversationId: GUID)}\n         * @example\n         * wonder.call(\"bob@example.com\", {video: true, data: PayloadType.chat})\n         * .then(function(conversationId){\n         *   // show video and send chat messages\n         * });\n         */\n        call(recipients, demand, conversationId, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            // errorCallback handling\n            if (!recipients) {\n              errMsg = new Error('[WONDER call] no recipients');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n            if (!demand) {\n              errMsg = new Error('[WONDER call] no demand');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n            demand = new Demand(demand); // convert the demand to the standard format\n\n            // TODO: only do that if no conversationId is given\n            var existingConversation = null;\n            if (typeof recipients === 'string' || recipients instanceof String) {\n              // check if te remote rtcIdentity is already in a conversation\n              existingConversation = that.conversations.find(\n                function(conversation) {\n                  return conversation.remoteParticipants.find(\n                    function(participant) {\n                      return participant.identity.rtcIdentity == recipients;\n                    }\n                  )\n                }\n              );\n            }\n            if (typeof recipients === 'array' || recipients instanceof Array) return new Error(\"[wonder call] multiparty no yet implemented\");\n\n            if (!existingConversation) {\n              // create a new conversation\n              var conversation = new Conversation(that, new Participant(that, that.myIdentity, demand)); // create me and set me as the owner\n              conversation.myParticipant = conversation.owner; // copy the reference to me\n              that.conversations.push(conversation); // add the conversation to wonder\n              conversation.myParticipant.setRtcPeerConnection(\n                new RTCPeerConnection({\n                  'iceServers': that.config.ice // name of key needs to be iceServers in RTCPeerConnection\n                    //,dataChannelOptions\n                })\n              );\n            } else {\n              var conversation = existingConversation;\n              conversation.myParticipant.updateDemand(demand);\n            }\n\n            // set ice handling to false before receiving all sdp messages to avoid ICE errors\n            conversation.msgEvtHandler.ice = false;\n\n            // dynamically load a file for a specific use case\n            // require file for a multiparty call\n            if (typeof recipients === 'array' || recipients instanceof Array) {\n              // TODO: implement multiparty support\n              if (demand.out.video || demand.out.audio) {\n                require(['callMultiple'], function(callMultiple) {\n                  callMultiple(wonderInstance, recipients, conversation)\n                    .then(function(conversationId) {\n                      resolve(conversationId);\n                      if (successCallback) successCallback(conversationId);\n                    })\n                    .catch(function(error) {\n                      errMsg = new Error(\"[WONDER call] Error in callMultiple occured: \", error);\n                      reject(errMsg);\n                      if (errorCallback) errorCallback(errMsg);\n                      return;\n                    });\n                });\n              }\n            }\n            // require file for a single call\n            else if (typeof recipients === 'string' || recipients instanceof String) {\n              // start a video / audio call\n              if (demand.out.video || demand.out.audio) {\n                require(['callSingle'], function(callSingle) {\n                  callSingle(that, recipients, conversation, demand)\n                    .then(function(conversationId) {\n                      resolve(conversationId);\n                      if (successCallback) successCallback(conversationId);\n                    })\n                    .catch(function(error) {\n                      errMsg = new Error(\"[WONDER call] Error in callSingle occured: \", error);\n                      reject(errMsg);\n                      if (errorCallback) errorCallback(errMsg);\n                      return;\n                    });\n                });\n              }\n              // start a data channel\n              if (demand.out.data) {\n                require(['dataChannel'], function(dataChannel) {\n                  dataChannel(that, recipients, conversation, demand.out.data) // also hand over the data object to tell what payload type is wanted\n                    .then(function(conversationId) {\n                      resolve(conversationId);\n                      if (successCallback) successCallback(conversationId);\n                    })\n                    .catch(function(error) {\n                      errMsg = new Error(\"[WONDER call] Error in dataChannel occured: \", error);\n                      reject(errMsg);\n                      if (errorCallback) errorCallback(errMsg);\n                      return;\n                    });\n                });\n              }\n            } else {\n              errMsg = new Error(\"[WONDER call] cannot determine wether it is a multi or single party call\");\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n          });\n        }\n\n\n\n        /**\n         * @desc A function to remove a reciepient from an existing conversation\n         * only used for multiparty calls\n         *\n         * @param {Array.<String>|String} recipients - The username(s) for the reciepients\n         * @param {GUID} [conversationId] - To remove a call from an exiting conversation\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         *\n         * @return {Promise<GUID>|function(conversationId: GUID)}\n         * !!! not implemented yet\n         * TODO: implement\n\n        removeRecipients(recipients, conversationId, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            // errorCallback handling\n            if (!recipients) {\n              errMsg = new Error('[WONDER removeRecipients] errorCallback: no reciepients given')\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n            // force an array construct\n            var rcpt = [];\n            if (typeof recipients === 'string') rcpt.push(recipients);\n            else rcpt = recipients;\n\n            // TODO : implement\n            // conversation.addParticipant(participant, invitationBody, constraints, function(){resolve()}, function(){reject()});\n\n          });\n        }\n        */\n\n        /**\n         * @desc Add demand to an existing conversation\n         *\n         * @param {Object} type - a media constraint object containing the new media constraints\n         * @param {GUID} [conversationId] - To add constraints to an exiting conversation\n         * @param {function} [successCallback] - A success callback.\n         * @param {function} [errorCallback] - An error callback.\n         *\n         * @return {Promise<GUID>|function(conversationId: GUID)}\n         * !!! not implemented yet\n         * TODO: implement\n\n        addDemand(type, conversationId, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            // errorCallback handling\n            if (!type) {\n              errMsg = new Error('[WONDER addDemand] errorCallback: no type given');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n          });\n        }\n         */\n\n        /**\n         * @desc Remove demand from an existing conversation\n         *\n         * @param {Object} type - a media constraint object containing the media constraints wich should be removed\n         * @param {GUID} [conversationId] - To remove constraints from an exiting conversation\n         * @param {function} [successCallback] - A success callback.\n         * @param {function} [errorCallback] - An error callback.\n         *\n         * @return {Promise<GUID>|function(conversationId: GUID)}\n         * !!! not implemented yet\n         * TODO: implement\n\n        removeDemand(type, conversationId, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            // errorCallback handling\n            if (!type) {\n              errMsg = new Error('[WONDER removeDemand] errorCallback: no type given');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n          });\n        }\n         */\n\n        /**\n         * @desc A function to logout a user from his and all other messaging servers.\n         * The hangup function will be called to close all conversations.\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         * @return {Promise<Boolean>|function(success: Boolean)}\n         * @example wonder.logout().then( function(){ ... } );\n         */\n        logout(successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            // errorCallback handling\n            if (!that.myIdentity) {\n              errMsg = new Error('[WONDER logout] not logged in');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n\n            // hangup all conversations\n            if (that.conversations.length > 0) that.hangup();\n\n            // disconnect from own messaging server\n            if (that.myIdentity.msgStub) that.myIdentity.msgStub.disconnect();\n            else {\n              errMsg = new Error(\"[WONDER logout] no messaging Stub present\");\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n              return;\n            }\n\n            resolve(true);\n            if (successCallback) successCallback(true);\n          });\n        }\n\n\n        /**\n         * @desc A function to hangup a single conversation or all conversations.\n         * @param {GUID} [conversationId] - Id of the of the conversation to be closed\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         * @return {Promise<Boolean>|function(success: Boolean)}\n         * @example wonder.hangup(conversationId).then( function(){ ... } );\n         */\n        hangup(conversationId, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            // error handling\n            if (that.conversations.length == 0) {\n              errMsg = new Error(\"[WONDER hangup] no conversation present\");\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n            }\n\n            if (!conversationId) { // hangup all conversations\n              for (var i = 0; i < that.conversations.length; i++) {\n                that.conversations[i].leave();\n              }\n              that.conversations = [];\n            } else { // close a single conversation\n              var conversation = that.conversations.find(function(id) {\n                return id == conversationId;\n              });\n              conversation.leave();\n              conversation = null; // TODO: check if a conversation of null is still in the array\n            }\n\n            resolve(true);\n            if (successCallback) successCallback(true);\n          });\n        }\n\n\n        /**\n         * @desc Sends a new data channel message via the RTCDataChannel.\n         * @param {Object} msg - An object containing the message to be sent\n         * @param {PayloadType|String} type - The type of the payload (as a string or the well known PayloadType) of the data channel message\n         * @param {GUID} [conversationId] - The conversationId of the conversation's data channel the message will be sent to\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         * @return {Promise<Boolean>|function(success: Boolean)}\n         * @example\n         * msg = \"Text or Message or Object or anything. Is handeled by the codec.\";\n         * wonder.dataChannelMsg(msg, PayloadType.plain, conversationId)\n         * .then(function(booleanValue){\n         *   // success\n         * });\n         */\n        dataChannelMsg(msg, type, conversationId, to, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n          console.log(\"[WONDER dataChannelMsg] \", msg);\n          return new Promise(function(resolve, reject) {\n            if (that.conversations.length == 0) {\n              errMsg = new Error(\"[WONDER dataChannelMsg] no conversation present\");\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n            }\n\n            // if no conversation use the dafault single party call method\n            if (!conversationId) {\n              var remoteIdentity = that.conversations[0].remoteParticipants[0].identity;\n              try {\n                that.conversations[0].dataChannelBroker.getDataChannelCodec(that.myIdentity, remoteIdentity, type).send(msg);\n                resolve(true);\n                if (successCallback) successCallback(true);\n              } catch (err) {\n                errMsg = new Error('[WONDER dataChannelMsg] There is no dataChannel for this Codec established');\n                reject(errMsg);\n                if (errorCallback) errorCallback(errMsg);\n              }\n            } else { // else find the conversation\n              var conversation = that.conversations.find(\n                function(conversation) {\n                  return conversation.id == conversationId;\n                }\n              );\n              if (conversation) { // and if it was found send the message\n                var remoteIdentity = conversation.remoteParticipants[0].identity;\n                conversation.dataChannelBroker.getDataChannelCodec(that.myIdentity, remoteIdentity, type).send(msg);\n                resolve(true);\n                if (successCallback) successCallback(true);\n              } else { // and if not throw an error\n                errMsg = new Error('[WONDER dataChannelMsg] no conversation found');\n                reject(errMsg);\n                if (errorCallback) errorCallback(errMsg);\n              }\n            }\n          });\n        }\n\n        /**\n         * @desc This function needs to be called if the autoAccept option in the WONDER instacne is false.\n         * It needs to be used after the invitation is received and an answer is necessary.\n         * @param {Message} msg - The invitation message to be accepted or declined\n         * @param {Boolean} action - A Boolean value (true = accepted, false = declined)\n         * @param {function} [successCallback] - A success callback\n         * @param {function} [errorCallback] - An error callback\n         * @return {Promise<GUID>|function(conversationId: GUID)}\n         * @example\n         *   wonder.onMessage = function(msg, conversationId){\n         *     switch (msg.type) {\n         *       case MessageType.invitation:\n         *         if(!wonder.config.autoAccept) {\n         *           var confirmDialog = confirm('Call from '+msg.from+'. Would you like to accept?');\n         *           if (confirmDialog == true) {\n         *               wonder.answerRequest(msg, true).then(function(){\n         *                 console.log('[main] Message invitation: user accepted invtitation');\n         *               });\n         *           } else {\n         *               wonder.answerRequest(msg, false).then(function(){\n         *                 console.log('[main] Message invitation: user declined invtitation');\n         *               });\n         *           }\n         *       }\n         *       break;\n         *     }\n         *   }\n         */\n        answerRequest(msg, action, successCallback, errorCallback) {\n          var that = this;\n          var errMsg = null;\n\n          return new Promise(function(resolve, reject) {\n            var conversation = that.conversations.find(\n              function(conversation) {\n                return conversation.id == msg.conversationId;\n              }\n            );\n            if (conversation) { // and if it was found send the message\n              conversation.msgEvthandler.answerRequest(msg, action);\n              resolve(conversation.id);\n              if (successCallback) successCallback(conversation.id);\n            } else { // and if not throw an error\n              errMsg = new Error('[WONDER answerRequest] no conversation found');\n              reject(errMsg);\n              if (errorCallback) errorCallback(errMsg);\n            }\n          });\n        }\n\n      }\n/*\n      return new WONDER();\n    });\n  } else if (typeof window === 'object') {\n    window.wonder = new WONDER();\n    // TODO implement other classes if framework isn't required as amd module\n  } else {\n    try {\n      module.exports = new WONDER();\n      // TODO import other classes if browser supports es6 import/export\n    } catch (e) {}\n  }\n})();\n*/\n"
  },
  {
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "WONDER",
    "memberof": "libs/wonder.js",
    "longname": "libs/wonder.js~WONDER",
    "access": null,
    "export": false,
    "importPath": "wonder_2.0/libs/wonder.js",
    "importStyle": null,
    "description": "The WONDER class is used for developers for interacting with all other WONDER related classes.\nThe class uses simple interfaces for login, call, etc.\nAll operations will start with wonder.<function-name> and will return a promise and a callback (either successCallback or errorCallback).",
    "examples": [
      "wonder.<funcion>(<params>).then(function(successCallbackData){<code>}, function(errorCallbackData){<code>})"
    ],
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      },
      {
        "tagName": "@alias",
        "tagValue": "module:wonder"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "WONDER"
      ],
      "spread": false,
      "description": ""
    },
    "interface": false
  },
  {
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#constructor",
    "access": null,
    "description": null,
    "examples": [
      "// needs to be included in a html file\n<script src=\"require.min.js\"></script>\n<script type=\"text/javascript\">\n  // require.config is optional and only necessary if the wonder framework is not in the same directory like require.js\n  // for additional information visit: http://requirejs.org/docs/api.html#config\n  require.config({\n    paths: { 'wonder': 'js/wonder' } // includes js/wonder.js\n  });\n  require(['wonder'], function(wonderInstance){\n    wonderInstance.login(\"alice@example.org\");\n    // do other things here like calling bob\n  });\n</script>"
    ],
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [],
    "generator": false
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "config",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#config",
    "access": null,
    "description": "An object with a configuration\nThe standard values are set by default when the user doesn't want to do\nit on his own.",
    "examples": [
      "{\n idp: 'webfinger',\n // alternatively an own idp with:\n // idp:{ url:  \"http://example.com\",\n //       port: '2222',\n //       path: '/u?jsonp=define&identity'   }\n autoAccept: false, // accept invitations automatically\n ice: [\n    {urls:'stun:stun.example.com'}, // stunserver\n    { // turnserver\n      urls: 'turn:turn.example.org:11111?transport=tcp',\n      credential: 'credeantialAccessString',\n      username: 'usernameToAccess'\n    }\n  ]\n}"
    ],
    "lineNumber": 80,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "conversations",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#conversations",
    "access": null,
    "description": "The conversations used in this WONDER instance",
    "lineNumber": 133,
    "type": {
      "nullable": null,
      "types": [
        "Array<Conversation>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "myIdentity",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#myIdentity",
    "access": null,
    "description": "The identity of the local user",
    "lineNumber": 139,
    "type": {
      "nullable": null,
      "types": [
        "Identity"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "localIdp",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#localIdp",
    "access": null,
    "description": "The local identity provider residing in the local WONDER instance\nused to interact with the remote identity provider. It is there to be\nable to abstact the remote identity provider and define a common\ninterface to WONDER functions.\nIt resolves identities via WebFinger or JSONP.",
    "lineNumber": 149,
    "type": {
      "nullable": null,
      "types": [
        "Idp"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "onMessage",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#onMessage",
    "access": null,
    "description": "The variable on which the framework user can register his own message event handler.\nIt is called after the WONDER framework is finished processing each message.\nIs meant to deliver events which originate from the messaging server.",
    "examples": [
      "wonder.onMessage = function(msg, conversationId) { ... }"
    ],
    "lineNumber": 158,
    "type": {
      "nullable": null,
      "types": [
        "function(msg: Message, conversationId: GUID)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "onRtcEvt",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#onRtcEvt",
    "access": null,
    "description": "The variable on which the framework user can register an event handler for wonder rtc (peer connection) events.\nIt is called after the WONDER framework is finished processing each\nIs meant to deliver events which originate from the peer connection to another user.",
    "examples": [
      "wonder.onRtcEvt = function(msg, conversationId) { ... }"
    ],
    "lineNumber": 168,
    "type": {
      "nullable": null,
      "types": [
        "function(msg: Object, conversationId: GUID)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "onDataChannelEvt",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#onDataChannelEvt",
    "access": null,
    "description": "The variable on which the framework user can register an event handler for wonder data channel events.\nIt is called after the WONDER framework is finished processing each\nIs meant to deliver events which originate from the peer connection's datachannels to another user.",
    "examples": [
      "wonder.onDataChannelEvt = function(msg, conversationId){ ... }"
    ],
    "lineNumber": 177,
    "type": {
      "nullable": null,
      "types": [
        "function(msg: Object, conversationId: GUID)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "login",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#login",
    "access": null,
    "description": "The function starts a user login at the identity provider.",
    "examples": [
      "wonder.login(\"alice@example.net\", \"\")\n.then(function(identity){\n  // use the identity to extract the user's aliases, avatar or other information\n});"
    ],
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "myRtcIdentity",
        "description": "The username (login name) of the local identity"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "credentials",
        "description": "An object with additional login credentials (password, sip-credentials, etc.); may be undefined or null or an empty string"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "successCallback",
        "description": "A success callback"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "errorCallback",
        "description": "An error callback"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Identity>",
        "function(identity: Identity)"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "call",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#call",
    "access": null,
    "description": "A function to start a new call.",
    "examples": [
      "wonder.call(\"bob@example.com\", {video: true, data: PayloadType.chat})\n.then(function(conversationId){\n  // show video and send chat messages\n});"
    ],
    "lineNumber": 272,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<String>",
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "recipients",
        "description": "The rtcIdentity as a string for the reciepients (e.g. alice@example.com)"
      },
      {
        "nullable": null,
        "types": [
          "String",
          "Array<String>",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "demand",
        "description": "An object with the own media constraints for the offer"
      },
      {
        "nullable": null,
        "types": [
          "GUID"
        ],
        "spread": false,
        "optional": true,
        "name": "conversationId",
        "description": "To assign a call to an exiting conversation"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "successCallback",
        "description": "A success callback"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "errorCallback",
        "description": "An error callback"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GUID>",
        "function(conversationId: GUID)"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "logout",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#logout",
    "access": null,
    "description": "A function to logout a user from his and all other messaging servers.\nThe hangup function will be called to close all conversations.",
    "examples": [
      "wonder.logout().then( function(){ ... } );"
    ],
    "lineNumber": 493,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "successCallback",
        "description": "A success callback"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "errorCallback",
        "description": "An error callback"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Boolean>",
        "function(success: Boolean)"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "hangup",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#hangup",
    "access": null,
    "description": "A function to hangup a single conversation or all conversations.",
    "examples": [
      "wonder.hangup(conversationId).then( function(){ ... } );"
    ],
    "lineNumber": 532,
    "params": [
      {
        "nullable": null,
        "types": [
          "GUID"
        ],
        "spread": false,
        "optional": true,
        "name": "conversationId",
        "description": "Id of the of the conversation to be closed"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "successCallback",
        "description": "A success callback"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "errorCallback",
        "description": "An error callback"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Boolean>",
        "function(success: Boolean)"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dataChannelMsg",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#dataChannelMsg",
    "access": null,
    "description": "Sends a new data channel message via the RTCDataChannel.",
    "examples": [
      "msg = \"Text or Message or Object or anything. Is handeled by the codec.\";\nwonder.dataChannelMsg(msg, PayloadType.plain, conversationId)\n.then(function(booleanValue){\n  // success\n});"
    ],
    "lineNumber": 578,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "An object containing the message to be sent"
      },
      {
        "nullable": null,
        "types": [
          "PayloadType",
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type of the payload (as a string or the well known PayloadType) of the data channel message"
      },
      {
        "nullable": null,
        "types": [
          "GUID"
        ],
        "spread": false,
        "optional": true,
        "name": "conversationId",
        "description": "The conversationId of the conversation's data channel the message will be sent to"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "successCallback",
        "description": "A success callback"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "errorCallback",
        "description": "An error callback"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Boolean>",
        "function(success: Boolean)"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "answerRequest",
    "memberof": "libs/wonder.js~WONDER",
    "longname": "libs/wonder.js~WONDER#answerRequest",
    "access": null,
    "description": "This function needs to be called if the autoAccept option in the WONDER instacne is false.\nIt needs to be used after the invitation is received and an answer is necessary.",
    "examples": [
      "  wonder.onMessage = function(msg, conversationId){\n    switch (msg.type) {\n      case MessageType.invitation:\n        if(!wonder.config.autoAccept) {\n          var confirmDialog = confirm('Call from '+msg.from+'. Would you like to accept?');\n          if (confirmDialog == true) {\n              wonder.answerRequest(msg, true).then(function(){\n                console.log('[main] Message invitation: user accepted invtitation');\n              });\n          } else {\n              wonder.answerRequest(msg, false).then(function(){\n                console.log('[main] Message invitation: user declined invtitation');\n              });\n          }\n      }\n      break;\n    }\n  }"
    ],
    "lineNumber": 649,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "The invitation message to be accepted or declined"
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "action",
        "description": "A Boolean value (true = accepted, false = declined)"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "successCallback",
        "description": "A success callback"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "errorCallback",
        "description": "An error callback"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GUID>",
        "function(conversationId: GUID)"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": null,
    "builtinExternal": true
  }
]